<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="AMD 的 FSR2，在 DLSS 不支持的硬件上不失为一种不错的超分算法选项。"><meta name=keywords content="AMD,FSR2,FidelityFX,SuperResolution"><title>GDC 笔记 - FidelityFX Super Resolution 2.0</title><link rel=canonical href=https://www.kindem.xyz/post/56/><link rel=stylesheet href=/scss/style.min.css><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?a0c486208ba4751b6988ccc92f1479ee",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><meta property="og:title" content="GDC 笔记 - FidelityFX Super Resolution 2.0"><meta property="og:description" content="AMD 的 FSR2，在 DLSS 不支持的硬件上不失为一种不错的超分算法选项。"><meta property="og:url" content="https://www.kindem.xyz/post/56/"><meta property="og:site_name" content="Kindem的博客"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="GDC"><meta property="article:published_time" content="2022-09-02T00:00:00+00:00"><meta property="article:modified_time" content="2022-09-02T00:00:00+00:00"><meta name=twitter:title content="GDC 笔记 - FidelityFX Super Resolution 2.0"><meta name=twitter:description content="AMD 的 FSR2，在 DLSS 不支持的硬件上不失为一种不错的超分算法选项。"><link rel="shortcut icon" href=#ZgotmplZ><script async src="https://www.googletagmanager.com/gtag/js?id=G-F3YCH8P4PP"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F3YCH8P4PP",{anonymize_ip:!1})}</script></head><body><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.body.dataset.scheme="dark":document.body.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended article-page with-toolbar"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header class=site-info><figure class=site-avatar><img src=/img/avatar_hu0f5c0aa158a4e8466efa1fc48b48096f_378948_300x0_resize_q75_box.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar>
<span class=emoji>🎯</span></figure><h1 class=site-name><a href=https://www.kindem.xyz/>Kindem的博客</a></h1><h2 class=site-description>层楼终究误少年，自由早晚乱余生</h2></header><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>归档</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>搜索</span></a></li><li><a href=/friends/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg><span>友链</span></a></li><li><a href=/%E5%85%B3%E4%BA%8E/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>关于</span></a></li><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>暗色模式</span></li></ol></aside><main class="main full-width"><div id=article-toolbar><a href=https://www.kindem.xyz/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>Back</span></a></div><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E6%8A%80%E6%9C%AF/>技术</a></header><h2 class=article-title><a href=/post/56/>GDC 笔记 - FidelityFX Super Resolution 2.0</a></h2><h3 class=article-subtitle>AMD 的 FSR2，在 DLSS 不支持的硬件上不失为一种不错的超分算法选项。</h3><footer class=article-time><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--published>Sep 02, 2022</time></footer></div></header><section class=article-content><blockquote><p>原文链接：<a class=link href=https://gpuopen.com/gdc-presentations/2022/GDC_FidelityFX_Super_Resolution_2_0.pdf target=_blank rel=noopener>GDC 2022 - FidelityFX Super Resolution 2.0</a></p></blockquote><p><figure style=flex-grow:177;flex-basis:427px><a href=/post/56/1.png data-size=1486x835><img src=/post/56/1.png srcset="/post/56/1_hu212fe8ba51faf969960430472c9b42a7_137507_480x0_resize_box_3.png 480w, /post/56/1_hu212fe8ba51faf969960430472c9b42a7_137507_1024x0_resize_box_3.png 1024w" width=1486 height=835 loading=lazy></a></figure></p><p>AMD FSR 2.0 版本，相对 FSR 1.0 架构上有较大改动。</p><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/2.png data-size=1481x832><img src=/post/56/2.png srcset="/post/56/2_hu26db394494c749f5b7ab2ea79ca76c3f_948093_480x0_resize_box_3.png 480w, /post/56/2_hu26db394494c749f5b7ab2ea79ca76c3f_948093_1024x0_resize_box_3.png 1024w" width=1481 height=832 loading=lazy></a></figure></p><p>先回顾下 FSR 1.0，FSR 1.0 推出于 2021 年七月，是 AMD 推出的空间域超分解决方案，高性能，易集成，比价友好的 MIT License，已经在很多游戏中被集成了。</p><p><figure style=flex-grow:178;flex-basis:428px><a href=/post/56/3.png data-size=1482x831><img src=/post/56/3.png srcset="/post/56/3_hu76c8821ecd9d6fb819076c1308fc1d8e_178607_480x0_resize_box_3.png 480w, /post/56/3_hu76c8821ecd9d6fb819076c1308fc1d8e_178607_1024x0_resize_box_3.png 1024w" width=1482 height=831 loading=lazy></a></figure></p><p>因为 FSR 1.0 是基于空间域的超分算法，好处就是很容易集成（直接挂在后处理最后就行了），但同时也有一些缺陷：</p><ul><li>FSR 1.0 的输入需要经过高质量的抗锯齿处理，这个问题就算是不考虑超分，也是一个比较头疼的问题，把 FSR 1.0 挂在低质量的 TAA 实现后面就会产生质量很差的输出，这意味着如果游戏没有实现抗锯齿就集成 FSR 1.0，就要花上更多的时间。</li><li>超分的质量取决于输入图像的分辨率，如果输入图像的分辨率太低，就没有足够的信息来重现细节，太低的分辨率还会导致一些画面的缺陷，比如闪烁、边缘模糊等，这种情况通常在使用 Performance 模式时出现。</li></ul><p><figure style=flex-grow:177;flex-basis:426px><a href=/post/56/4.png data-size=1480x833><img src=/post/56/4.png srcset="/post/56/4_huab62ee017e53bd496a7eff20fa4a497c_205907_480x0_resize_box_3.png 480w, /post/56/4_huab62ee017e53bd496a7eff20fa4a497c_205907_1024x0_resize_box_3.png 1024w" width=1480 height=833 loading=lazy></a></figure></p><p>FSR 2.0 是下一代超分解决方案，不再基于空间域，而是基于时空域。FSR 2.0 与 FSR 1.0 并不兼容，需要不同的输入，并且直接内置了抗锯齿。质量要比 1.0 更高，提供了不同的 Quality Mode，同时支持了动态分辨率。跟 FSR 1.0 一样的是开源、跨平台、高度优化，不需要硬件支持的深度学习（内涵 DLSS），以 C++ / HLSL 库的方式提供 API，并且可以随意定制。</p><p><figure style=flex-grow:178;flex-basis:428px><a href=/post/56/5.png data-size=1481x829><img src=/post/56/5.png srcset="/post/56/5_hub0ec71b361fdae4e5857f0c9ede6527a_48629_480x0_resize_box_3.png 480w, /post/56/5_hub0ec71b361fdae4e5857f0c9ede6527a_48629_1024x0_resize_box_3.png 1024w" width=1481 height=829 loading=lazy></a></figure></p><p>算法介绍。</p><p><figure style=flex-grow:178;flex-basis:428px><a href=/post/56/6.png data-size=1481x829><img src=/post/56/6.png srcset="/post/56/6_hubc82d09d0aaf0ca1d8008f9c2b4c5870_92375_480x0_resize_box_3.png 480w, /post/56/6_hubc82d09d0aaf0ca1d8008f9c2b4c5870_92375_1024x0_resize_box_3.png 1024w" width=1481 height=829 loading=lazy></a></figure></p><p>FSR 2.0 的输入和 1.0 不再一样，输入为渲染尺寸的 Color、Depth、Motion（像素相比前一帧的位移）。与之对比，FSR 1.0 只有 Scene Color。</p><p><figure style=flex-grow:177;flex-basis:426px><a href=/post/56/7.png data-size=2891x1626><img src=/post/56/7.png srcset="/post/56/7_hu36cc0d6e06004dce13099ee74d30dfce_535374_480x0_resize_box_3.png 480w, /post/56/7_hu36cc0d6e06004dce13099ee74d30dfce_535374_1024x0_resize_box_3.png 1024w" width=2891 height=1626 loading=lazy></a></figure></p><p>RenderGraph。</p><p><figure style=flex-grow:177;flex-basis:427px><a href=/post/56/8.png data-size=1838x1033><img src=/post/56/8.png srcset="/post/56/8_hu5a9930013c26c57a750c69940054e254_186835_480x0_resize_box_3.png 480w, /post/56/8_hu5a9930013c26c57a750c69940054e254_186835_1024x0_resize_box_3.png 1024w" width=1838 height=1033 loading=lazy></a></figure></p><p>FSR 是基于 TAA 的，TAA 大家都比较熟悉了，对每一帧的像素进行抖动，在多帧间累加不同的采样点，从而达到多采样的效果，采样点越多，最终抗锯齿的效果就会越好。Jitter 序列的质量会直接影响到最终的效果，所以 Jitter 序列需要在时空域上有良好的分布，这样地分辨率的输入图像中的每一个像素都能在 Jitter 之后被采样点均匀覆盖。虽然理论上 Jitter 序列的长度是可以无穷大的，但是为了处理 Thin Features （后面会提到），FSR 2.0 在 Jitter 序列长度的设定上有一些自己的考虑。</p><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/9.png data-size=1382x776><img src=/post/56/9.png srcset="/post/56/9_hu32658d84cfca89c31c921aec1b490140_115204_480x0_resize_box_3.png 480w, /post/56/9_hu32658d84cfca89c31c921aec1b490140_115204_1024x0_resize_box_3.png 1024w" width=1382 height=776 loading=lazy></a></figure></p><p>每一个历史帧的采样点对新一帧的像素都会产生影响，但是采样点是有自己的权重的，取决于两个要素：</p><ul><li>采样点与目标像素的空间相关度（也就是距离），距离越近，权重越高。</li><li>采样点与目标像素的时间相关度（采样点所属历史帧的年龄），年龄越小，权重越高。</li></ul><p>如图所示，灰色方块表示一个像素，红点为像素中心，蓝点为采样点，第 N - 1 帧的采样点很靠近像素中心，理所当然要被纳入考虑范围，而第 N 帧的采样点虽然离得比较远，但是因为年龄较小，所以也有一定权重。</p><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/10.png data-size=1380x774><img src=/post/56/10.png srcset="/post/56/10_hu11848a0a7355e8139a3ff09223dd112f_141696_480x0_resize_box_3.png 480w, /post/56/10_hu11848a0a7355e8139a3ff09223dd112f_141696_1024x0_resize_box_3.png 1024w" width=1380 height=774 loading=lazy></a></figure></p><ul><li>第一个公式是新采样点与已经计算好的像素颜色混合的公式。S 是新增采样点，H 是已经累加的历史颜色，alpha 是混合的权重。</li><li>第二个公式是混合权重的计算公式，omega 是新增采样点的空间域权重（距离），tau 是该像素的空间域总权重。要注意的是这个公式中实际上并没有引入任何时间相关的变量，所以历史采样点在时间域上的空间都是一样的，但是因为历史采样点的权重在分母，会被新加入的采样点不断稀释，从而达到强调新加入采样点的目的。</li></ul><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/11.png data-size=1381x775><img src=/post/56/11.png srcset="/post/56/11_hu552c9f09a300f7105f68d573d9cfab1c_81446_480x0_resize_box_3.png 480w, /post/56/11_hu552c9f09a300f7105f68d573d9cfab1c_81446_1024x0_resize_box_3.png 1024w" width=1381 height=775 loading=lazy></a></figure></p><p>在 FSR 2.0 中，输入图像是低分辨率的，输出图像是高分辨率的，所以中间有上采样的步骤。一个灰色方块还是一个像素，灰色的点代表输出的高分辨率像素的中心，蓝点代表 Jitter 得到的采样点。上采样的过程主要是使用 Lanczos 插值算法。</p><p><figure style=flex-grow:75;flex-basis:181px><a href=/post/56/12.png data-size=1058x1400><img src=/post/56/12.png srcset="/post/56/12_hucf5251bff4e6402294152574eda569d0_134067_480x0_resize_box_3.png 480w, /post/56/12_hucf5251bff4e6402294152574eda569d0_134067_1024x0_resize_box_3.png 1024w" width=1058 height=1400 loading=lazy></a></figure></p><p>一维 Lanczos 插值公式中，a 表示核的大小。x 为输入，L(x) 为输入点的权重，二维 Lanczos 公式就是分别在 x,y 方向上做两次。</p><p><figure style=flex-grow:178;flex-basis:429px><a href=/post/56/13.png data-size=1381x772><img src=/post/56/13.png srcset="/post/56/13_hu2728726f5f09f2330e025eabbd3bb6c6_124300_480x0_resize_box_3.png 480w, /post/56/13_hu2728726f5f09f2330e025eabbd3bb6c6_124300_1024x0_resize_box_3.png 1024w" width=1381 height=772 loading=lazy></a></figure></p><p>在 FSR 2.0 中，对于每一个目标像素 P，都使用核为 2x2 的二维 Lanczos 公式进行插值，所有参与最终混合的采样点的权重都通过 Lanczos 公式计算。</p><p><figure style=flex-grow:178;flex-basis:428px><a href=/post/56/14.png data-size=1379x772><img src=/post/56/14.png srcset="/post/56/14_hue94b4f1e29a500f49cf6f0e2c781d763_127386_480x0_resize_box_3.png 480w, /post/56/14_hue94b4f1e29a500f49cf6f0e2c781d763_127386_1024x0_resize_box_3.png 1024w" width=1379 height=772 loading=lazy></a></figure></p><p>从低分辨率到高分辨率需要更锐利的采样，在原有公式的基础上添加了一个系数 belta，用于对二维 Lanczos 函数的 xy 轴分别做缩放，belta 根据局部的 Luminance Stability （应该就是边缘度?）计算得到。</p><p><figure style=flex-grow:177;flex-basis:427px><a href=/post/56/15.png data-size=1383x777><img src=/post/56/15.png srcset="/post/56/15_hu41fdaecff8da8a293a22afd82c534a8c_399393_480x0_resize_box_3.png 480w, /post/56/15_hu41fdaecff8da8a293a22afd82c534a8c_399393_1024x0_resize_box_3.png 1024w" width=1383 height=777 loading=lazy></a></figure></p><ul><li>上面的 Upscaling 流程做了一个基本假设，就是输入图像在时空域上是静态的，所以为了处理动画，需要引入 Motion Vectors。</li><li>Motion Vectors 描述了采样点如何从前一帧移动到当前帧。Motion Vectors 必须取消 Jitter，这样当图像静止的时候，Motion Vectors 也应该为 0。</li><li>为了正确地跟随边缘，很多基于 TAA 的解决方案都会取 3x3 领域中最近的值，之后会详细说。</li></ul><p>如图所示，通过 Frame N - 1 和 Frame N，可以计算出来箭头所示的 Motion Vectors。</p><p><figure style=flex-grow:177;flex-basis:427px><a href=/post/56/16.png data-size=1379x775><img src=/post/56/16.png srcset="/post/56/16_hu76e8121a7461e3cb0669df76df1819e2_377275_480x0_resize_box_3.png 480w, /post/56/16_hu76e8121a7461e3cb0669df76df1819e2_377275_1024x0_resize_box_3.png 1024w" width=1379 height=775 loading=lazy></a></figure></p><p>在场景运动时，前一帧的颜色信息需要重投影到当前帧。具体是根据 Motion Vectors 来计算采样点的历史位置，并且将其投影到当前帧，这一步依然使用 Lanczos 算法，在 Upsample Stage 完成。</p><p><figure style=flex-grow:178;flex-basis:428px><a href=/post/56/17.png data-size=1383x774><img src=/post/56/17.png srcset="/post/56/17_hu61f42b655d162a8dd7f8943f3f6e853b_272761_480x0_resize_box_3.png 480w, /post/56/17_hu61f42b655d162a8dd7f8943f3f6e853b_272761_1024x0_resize_box_3.png 1024w" width=1383 height=774 loading=lazy></a></figure></p><p>有些情况下历史帧的数据跟当前帧已经没有任何关系了，这时候将历史帧的信息投影到当前帧就会有鬼影问题（无用的历史颜色信息在当前帧可见）。常见的情况有 Disocclusion、Shading Changes （光照变化、纹理变化）等。如图所示，机器人的爪子部分有鬼影。</p><p><figure style=flex-grow:178;flex-basis:428px><a href=/post/56/18.png data-size=1382x774><img src=/post/56/18.png srcset="/post/56/18_hu10d17f0f6be4dddd0cbc0168baeddc28_291376_480x0_resize_box_3.png 480w, /post/56/18_hu10d17f0f6be4dddd0cbc0168baeddc28_291376_1024x0_resize_box_3.png 1024w" width=1382 height=774 loading=lazy></a></figure></p><p>针对这些情况需要单独处理，首先是 Disocclusion。通过比较当前帧的深度和重建得到的历史帧深度得到一张 Disocclusion Mask，然后通过 Disocclusion Mask 来检测 Disocclusion。</p><p><figure style=flex-grow:177;flex-basis:426px><a href=/post/56/19.png data-size=1278x719><img src=/post/56/19.png srcset="/post/56/19_hu08efd22b6e10404aabe85fba1f8a0326_109788_480x0_resize_box_3.png 480w, /post/56/19_hu08efd22b6e10404aabe85fba1f8a0326_109788_1024x0_resize_box_3.png 1024w" width=1278 height=719 loading=lazy></a></figure></p><p>重建历史帧深度的流程：</p><ul><li>将当前帧深度的采样点重投影到历史帧</li><li>Gather 周边的四个点，将他们都设置为当前帧的深度</li><li>重复上述过程，每个像素如果同时受多个当前帧像素的影响，取最近的深度作为最后的结果</li></ul><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/20.png data-size=1597x897><img src=/post/56/20.png srcset="/post/56/20_hu09775de0bc74fc7f2101087541cc83f3_126503_480x0_resize_box_3.png 480w, /post/56/20_hu09775de0bc74fc7f2101087541cc83f3_126503_1024x0_resize_box_3.png 1024w" width=1597 height=897 loading=lazy></a></figure></p><p>Disocclusion Mask 使用的具体方法：</p><ul><li>对于每一个采样点，我们可以得到当前帧的深度 D 和前一帧的深度 Dp</li><li>设置一个容忍度 MinDepthSep</li><li>如果 Dp - D > MinDepthSep 我们就认为产生了 Disocclusion</li></ul><p><figure style=flex-grow:177;flex-basis:427px><a href=/post/56/21.png data-size=1598x898><img src=/post/56/21.png srcset="/post/56/21_huf3c2c6f57cd42ae9cb1e7b8f6a978ff9_80628_480x0_resize_box_3.png 480w, /post/56/21_huf3c2c6f57cd42ae9cb1e7b8f6a978ff9_80628_1024x0_resize_box_3.png 1024w" width=1598 height=898 loading=lazy></a></figure></p><p>有了 Disocclusion Mask 就可以做历史颜色矫正了，需要先声明的一点是所有的矫正都只使用当前帧的信息，因为历史帧的信息可能会导致鬼影，违背了矫正的目的。</p><p><figure style=flex-grow:177;flex-basis:426px><a href=/post/56/22.png data-size=1597x898><img src=/post/56/22.png srcset="/post/56/22_huec0d73d66211406bee373fefc1ca09b1_130348_480x0_resize_box_3.png 480w, /post/56/22_huec0d73d66211406bee373fefc1ca09b1_130348_1024x0_resize_box_3.png 1024w" width=1597 height=898 loading=lazy></a></figure></p><p>如果检测到了某个采样点产生了 Disocclusion：</p><ul><li>首先需要丢弃绝大部分历史累积的颜色。全部丢弃会让画面看起来不那么平滑，所以还需要保留一小部分历史颜色，这会产生微小的鬼影，不过一般不是这么容易被注意到。</li><li>对于新加入的采样点，需要对其做 Blurred，这是前面 Upscaling Stage 就完成的，就是在计算权重的时候稍微减小 belta 的值。</li></ul><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/23.png data-size=1596x895><img src=/post/56/23.png srcset="/post/56/23_hu4d4e8e97000d6cc8e5fa42f7dd68ef8e_113331_480x0_resize_box_3.png 480w, /post/56/23_hu4d4e8e97000d6cc8e5fa42f7dd68ef8e_113331_1024x0_resize_box_3.png 1024w" width=1596 height=895 loading=lazy></a></figure></p><p>前面说到除了 Disocclusion，Shading Changes 同样也会导致鬼影。就算是错误的，历史帧的信息依然有一定价值，所以我们不能简单地将其丢弃，而是在当前帧 3x3 的邻域中将所有颜色映射到 Lunminance/Chrominance 空间，然后计算一个 Clamping Box，再将错误的历史帧颜色 Clamp 到范围内，接着使用。</p><p><figure style=flex-grow:177;flex-basis:425px><a href=/post/56/24.png data-size=1597x900><img src=/post/56/24.png srcset="/post/56/24_hu08556f55333a459f1b5455bc1184845f_671525_480x0_resize_box_3.png 480w, /post/56/24_hu08556f55333a459f1b5455bc1184845f_671525_1024x0_resize_box_3.png 1024w" width=1597 height=900 loading=lazy></a></figure></p><p>另外一点需要注意的是细微特征的处理。这种细微的特种在 Jitter 序列中获得的采样点信息并不足够，所以前面提到的颜色矫正会把他们当成 Shading Changes 干掉，比较常见的常见是 Specular 高光。这个问题就会导致输出图像不稳定，部分位置比较模糊，如图所示，右图的扶手部分放大了看就出现了着色不足的现象。</p><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/25.png data-size=1598x897><img src=/post/56/25.png srcset="/post/56/25_hu2d0fb7f6fb41ff675994cdcdf389bc3e_727198_480x0_resize_box_3.png 480w, /post/56/25_hu2d0fb7f6fb41ff675994cdcdf389bc3e_727198_1024x0_resize_box_3.png 1024w" width=1598 height=897 loading=lazy></a></figure></p><p>对于细微特征需要单独处理一下：</p><ul><li>检测像素的起伏并且锁定突兀的像素</li><li>被锁定的项目在颜色矫正阶段会获得更高的权重，以免被干掉</li></ul><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/26.png data-size=1725x968><img src=/post/56/26.png srcset="/post/56/26_hudb3b976b3962b805379ea57cc0e2c5f6_104699_480x0_resize_box_3.png 480w, /post/56/26_hudb3b976b3962b805379ea57cc0e2c5f6_104699_1024x0_resize_box_3.png 1024w" width=1725 height=968 loading=lazy></a></figure></p><p>一旦某个像素被锁定，在整个 Jitter 序列中，锁都会持续生效，可以通过老化机制隐式地移除超出生命周期的锁。Jitter 序列要在保证效果的同时足够短，以便锁可以尽快释放。</p><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/27.png data-size=1725x969><img src=/post/56/27.png srcset="/post/56/27_hu2b5c069bc21d9b6c35fb2b29c3bf794a_408996_480x0_resize_box_3.png 480w, /post/56/27_hu2b5c069bc21d9b6c35fb2b29c3bf794a_408996_1024x0_resize_box_3.png 1024w" width=1725 height=969 loading=lazy></a></figure></p><p>在产生 Disocclusion 或者 Shading Changes 后，锁就不再有效了。像前面说的一样通过老化机制来移除锁肯定是不够快的，此时就会产生鬼影。如图所示，黄色的拖影就是未能及时释放的锁。我们需要显式地检测这些锁并及时释放他们。</p><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/28.png data-size=1726x968><img src=/post/56/28.png srcset="/post/56/28_hu7e3e892b2a3103754832a7a410bb46d0_109128_480x0_resize_box_3.png 480w, /post/56/28_hu7e3e892b2a3103754832a7a410bb46d0_109128_1024x0_resize_box_3.png 1024w" width=1726 height=968 loading=lazy></a></figure></p><ul><li>对于 Disocclusion，同样可以使用前面提到的 Disocclusion Mask 来处理</li><li>对于 Shading Changes，在局部、低频空间对锁定颜色和新颜色进行亮度比较，如果差值大于一个规定的阈值，就把锁干掉</li></ul><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/29.png data-size=1728x970><img src=/post/56/29.png srcset="/post/56/29_hue1fce20beb524c11d0b99ce685c4a838_141700_480x0_resize_box_3.png 480w, /post/56/29_hue1fce20beb524c11d0b99ce685c4a838_141700_1024x0_resize_box_3.png 1024w" width=1728 height=970 loading=lazy></a></figure></p><p>因为通常 FSR 2.0 是在 ToneMapping 前，会遇到另一个 TAA 解决方案中常见的问题，Firefly Artifacts，产生的原因是拥有较大 HDR 颜色值的采样点参与多采样时，其对最终效果的影响会远远大于其他采样点，从观感上来看表现为边缘的走样。FSR 2.0 用了跟其他 TAA 解决方案类似的处理方法，即 Local Reversible ToneMapping。</p><p><figure style=flex-grow:182;flex-basis:437px><a href=/post/56/30.png data-size=1917x1051><img src=/post/56/30.png srcset="/post/56/30_hub22af4d754eeec679aec9d2960e4386f_241653_480x0_resize_box_3.png 480w, /post/56/30_hub22af4d754eeec679aec9d2960e4386f_241653_1024x0_resize_box_3.png 1024w" width=1917 height=1051 loading=lazy></a></figure></p><p>一个示例 Shader，简单来说就是在多采样输入时先进行一次带权重的 ToneMapping，降低高强度 HDR 值在结果中的占比，计算完再对输出进行一次 ToneMappingInvert 还原回去。因为计算完还会还原，所以 FSR 2.0 在内部做的 ToneMapping 对用户是无感的，整个输入输出都还是 HDR。这个功能在 FSR 2.0 Pipeline 中是可选的，需要手动配置开启。</p><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/31.png data-size=1727x970><img src=/post/56/31.png srcset="/post/56/31_hu0431478e662ffb2111936a1d1a8a1d8d_180744_480x0_resize_box_3.png 480w, /post/56/31_hu0431478e662ffb2111936a1d1a8a1d8d_180744_1024x0_resize_box_3.png 1024w" width=1727 height=970 loading=lazy></a></figure></p><p>另外一个 HDR 相关的话题是两个会影响到 FSR 2.0 输出质量的参数，一个是很多引擎会使用的预曝光，通常预曝光会持续到 ToneMapping Stage 被 Cancel 掉，这意味着它会影响到 FSR 2.0 的输入，因为 FSR 2.0 会使用到历史帧的数据，而预曝光参数有可能在帧间变化，所以需要把这个参数传递给 FSR 2.0 使其能够做出一些调整。另外一个参数是曝光度本身，也是类似的原理，如果引擎没有曝光度，FSR 2.0 也可以添加一个自动曝光 Pass 来做相关的处理。</p><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/32.png data-size=1727x969><img src=/post/56/32.png srcset="/post/56/32_hu3bbde29d30364173fb3a560ba3605d0d_281658_480x0_resize_box_3.png 480w, /post/56/32_hu3bbde29d30364173fb3a560ba3605d0d_281658_1024x0_resize_box_3.png 1024w" width=1727 height=969 loading=lazy></a></figure></p><p>DRS，动态分辨率缩放，可以让游戏引擎根据当前负载动态调整渲染分辨率，使其即便在负载比较高的情况下也能输出一个效果较好的渲染结果。FSR 2.0 天生就支持 DRS，因为 FSR 2.0 内部的绝大部分工作都只依赖渲染分辨率的输入，而所有需要持久化保存的数据（如 Pixel Locks）都按照显示分辨率保存，所以无论输入分辨率怎么变化其实 FSR 2.0 都能处理。如图所示，连续几帧画面的分辨率各不相同，最终的输出分辨率都是一致的。</p><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/33.png data-size=1725x968><img src=/post/56/33.png srcset="/post/56/33_hu3cf424d19740448f05aa39741fc1ffb6_756141_480x0_resize_box_3.png 480w, /post/56/33_hu3cf424d19740448f05aa39741fc1ffb6_756141_1024x0_resize_box_3.png 1024w" width=1725 height=968 loading=lazy></a></figure></p><p>FSR 2.0 跟 FSR 1.0 一样在 Upscaling 之后会提高一个 Sharpening Stage 来做锐化提高画面细节，依赖的是 AMD 的另外一个技术 RCAS。</p><p><figure style=flex-grow:178;flex-basis:428px><a href=/post/56/34.png data-size=1725x967><img src=/post/56/34.png srcset="/post/56/34_hu19042f17890189d08462be85d70273ea_56124_480x0_resize_box_3.png 480w, /post/56/34_hu19042f17890189d08462be85d70273ea_56124_1024x0_resize_box_3.png 1024w" width=1725 height=967 loading=lazy></a></figure></p><p>讲完了算法，接着讲一下优化部分。</p><p><figure style=flex-grow:178;flex-basis:428px><a href=/post/56/35.png data-size=1730x968><img src=/post/56/35.png srcset="/post/56/35_hu19897f1e683c502de3264dcd961da942_154555_480x0_resize_box_3.png 480w, /post/56/35_hu19897f1e683c502de3264dcd961da942_154555_1024x0_resize_box_3.png 1024w" width=1730 height=968 loading=lazy></a></figure></p><p>首先是前面提到的 Local Reversible ToneMapping，在 FSR 2.0 Pipeline 中的很多地方都使用了 Local Reversible ToneMapping，用于处理输出数据提高输出质量。早期的实现版本中一些 ToneMapping 操作是 Per-Sample 的，而且有很多采样相邻像素的操作，占用了大量的 ALU 资源。优化的目标是接近 Per-Pixel，释放 ALU 资源给其他的计算。</p><p><figure style=flex-grow:178;flex-basis:428px><a href=/post/56/36.png data-size=1729x968><img src=/post/56/36.png srcset="/post/56/36_huaecd711988283c0c364f3a429875492a_200352_480x0_resize_box_3.png 480w, /post/56/36_huaecd711988283c0c364f3a429875492a_200352_1024x0_resize_box_3.png 1024w" width=1729 height=968 loading=lazy></a></figure></p><p>FSR 2.0 算法非常依赖显存带宽，所以提升 GPU Cache 命中率很重要。对于 4k 场景来说，数据量远远超过了 GPU 的可用 Cache，就算是拥有 Infinity Cache 技术的最新架构 RDNA2 都没法 Cover。为了解决这个问题，FSR 2.0 会把单个大的 Compute Shader Dispatch 指令拆分成多个小的 Dispatch 指令，来提高 Cache 命中率。</p><p><figure style=flex-grow:178;flex-basis:428px><a href=/post/56/37.png data-size=1727x967><img src=/post/56/37.png srcset="/post/56/37_hu8283217eadb122ea1af2bd3794389229_203531_480x0_resize_box_3.png 480w, /post/56/37_hu8283217eadb122ea1af2bd3794389229_203531_1024x0_resize_box_3.png 1024w" width=1727 height=967 loading=lazy></a></figure></p><p>在 AMD Radeon RX 6800XT 上 L0 Cache 命中率有 37% 的提升。</p><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/38.png data-size=1728x969><img src=/post/56/38.png srcset="/post/56/38_hu6dc79efc98fc0af10a0ffd8781fc813c_330136_480x0_resize_box_3.png 480w, /post/56/38_hu6dc79efc98fc0af10a0ffd8781fc813c_330136_1024x0_resize_box_3.png 1024w" width=1728 height=969 loading=lazy></a></figure></p><p>按照之前说的，FSR 2.0 提供了自动曝光选项，以便在引擎不提供曝光度输入时自动计算输入图像的曝光度，这部分计算有一定开销。最开始这部分计算效率是比较低的，使用了单线程 Dispatch 或者 1x1 RenderTarget 的 PixelShader，GPU 利用率很低。优化的方法是使用 AMD 的另外一个技术，Single Pass Downsampler，SPD，SPD 通常用于高效地对图像进行连续降采样，比如 Mipmaps 的生成就可以使用。SPD 具有可配置的 Kernal，可以将 SPD 配置成降采样到单个像素来计算曝光度，从而提高性能。1080p， 6800XT 仅需要 17us 来计算曝光度。</p><p><figure style=flex-grow:178;flex-basis:428px><a href=/post/56/39.png data-size=1727x968><img src=/post/56/39.png srcset="/post/56/39_hu1dab7b9d9652935162fb520171aa4eb9_237341_480x0_resize_box_3.png 480w, /post/56/39_hu1dab7b9d9652935162fb520171aa4eb9_237341_1024x0_resize_box_3.png 1024w" width=1727 height=968 loading=lazy></a></figure></p><p>之前说了上采样的时候会使用 Lanczos 插值来计算采样点对最终像素的贡献权重，Lanczos 公式还是比较费的，尤其是在老的硬件上。优化方法是在保证质量的基础上沿袭 FSR 1.0 的做法，对 Lanczos 公式做一个近似，这样可以减少 ALU 压力，另外就是把 Lanczos Look Up Table 做成一张 LUT Texture 来加速 Lookup，这两个优化在自家硬件上都还有额外的效果。</p><p><figure style=flex-grow:177;flex-basis:426px><a href=/post/56/40.png data-size=1727x971><img src=/post/56/40.png srcset="/post/56/40_hu7f9ae1f94b3cc9dea6b539a1315ca47d_150902_480x0_resize_box_3.png 480w, /post/56/40_hu7f9ae1f94b3cc9dea6b539a1315ca47d_150902_1024x0_resize_box_3.png 1024w" width=1727 height=971 loading=lazy></a></figure></p><p>在 RNDA 架构中，GPU 可以在 Wave32 和 Wave64 两种模式下运作（GCN 架构只有 Wave64）。通常情况下 Wave32 模式要比 Wave64 模式更快，因为延迟更小。但是在一些特殊场景下 Wave64 模式会更快。默认情况下 FSR 2.0 的 Shader 在 Wave32 模式下工作，但是 FSR 2.0 的一些运算在 Wave64 模式下会工作地更快。</p><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/41.png data-size=1728x970><img src=/post/56/41.png srcset="/post/56/41_hu66a3c18e57b50d291d0c4bd28c09b3df_276657_480x0_resize_box_3.png 480w, /post/56/41_hu66a3c18e57b50d291d0c4bd28c09b3df_276657_1024x0_resize_box_3.png 1024w" width=1728 height=970 loading=lazy></a></figure></p><p>实测下来强制 Wave64 模式 FSR 2.0 的不少 Stage 都有更高的收益。在 Shader Model 6.6 下，可以在 Shader 源码中指定使用哪种模式，在 FSR 2.0 正式开源后，开发者可以根据自己的需要选择哪种模式运行。</p><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/42.png data-size=1726x969><img src=/post/56/42.png srcset="/post/56/42_hue6a2ceb2cea17e5f021e765ab18acdbf_182275_480x0_resize_box_3.png 480w, /post/56/42_hue6a2ceb2cea17e5f021e765ab18acdbf_182275_1024x0_resize_box_3.png 1024w" width=1726 height=969 loading=lazy></a></figure></p><p>因为 FSR 2.0 是跨平台的，需要支持各种各样的 GPU，这样自己 RDNA2 架构上的优化在别的 GPU 上有可能是负优化。所以在别的 GPU 上运行时，会做一些 Fallback，有一些优化不会开启，比如 Wave64 模式就只在 AMD GPU 上默认打开。集成 FSR 2.0 的时候可以直接使用 AMD 的推荐配置，可以帮助根据硬件自动选择最佳参数，FSR 2.0 在性能上肯定是很能打的。</p><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/43.png data-size=1728x969><img src=/post/56/43.png srcset="/post/56/43_hu7ef174a2fed1b2047b6729063726a5b4_141349_480x0_resize_box_3.png 480w, /post/56/43_hu7ef174a2fed1b2047b6729063726a5b4_141349_1024x0_resize_box_3.png 1024w" width=1728 height=969 loading=lazy></a></figure></p><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/44.png data-size=1725x968><img src=/post/56/44.png srcset="/post/56/44_hu31b048f40dfe064ac1295dfd8650a9b6_143164_480x0_resize_box_3.png 480w, /post/56/44_hu31b048f40dfe064ac1295dfd8650a9b6_143164_1024x0_resize_box_3.png 1024w" width=1725 height=968 loading=lazy></a></figure></p><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/45.png data-size=1725x969><img src=/post/56/45.png srcset="/post/56/45_hu76d20c62ecb5621dba6fd0a0f55012d7_149000_480x0_resize_box_3.png 480w, /post/56/45_hu76d20c62ecb5621dba6fd0a0f55012d7_149000_1024x0_resize_box_3.png 1024w" width=1725 height=969 loading=lazy></a></figure></p><p>2022 年 3 月 FSR 2.0 Beta3 版本几种模式下的性能数据，4k Quality Mode 只需要 1.1ms，还是很可观的，类似的超分算法 DLSS 就要差很多，而且这个时间还是可以 Cover TAA 的开销，还是很可观的。</p><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/46.png data-size=1726x969><img src=/post/56/46.png srcset="/post/56/46_hu5966dd0c8f8a93f623c0e73490e00521_55105_480x0_resize_box_3.png 480w, /post/56/46_hu5966dd0c8f8a93f623c0e73490e00521_55105_1024x0_resize_box_3.png 1024w" width=1726 height=969 loading=lazy></a></figure></p><p>FSR 2.0 的集成。</p><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/47.png data-size=1725x968><img src=/post/56/47.png srcset="/post/56/47_huea500052076132870d1c27dfd9ab6655_156187_480x0_resize_box_3.png 480w, /post/56/47_huea500052076132870d1c27dfd9ab6655_156187_1024x0_resize_box_3.png 1024w" width=1725 height=968 loading=lazy></a></figure></p><p>FSR 2.0 设计的一大目标就是良好地兼容性：</p><ul><li>支持所有 GPU</li><li>不依赖 ML 硬件</li><li>支持老的 GPU 架构</li></ul><p>另外还会提供 DX12、Vulkan 的 Samples，提供 UE4.26 和 UE4.27 的插件，提供 Xbox GDKX 的 Samples，无论是什么平台，FSR 2.0 都能完美集成。</p><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/48.png data-size=1725x969><img src=/post/56/48.png srcset="/post/56/48_hu929a4113b9c62d5a737a5d502104397d_196672_480x0_resize_box_3.png 480w, /post/56/48_hu929a4113b9c62d5a737a5d502104397d_196672_1024x0_resize_box_3.png 1024w" width=1725 height=969 loading=lazy></a></figure></p><p>因为 FSR 2.0 的工作流很复杂，所以专门设计了一套 API 来便于开发者方便地集成。</p><p><figure style=flex-grow:177;flex-basis:426px><a href=/post/56/49.png data-size=1724x970><img src=/post/56/49.png srcset="/post/56/49_huad89d34689f7791d88edb93809b3c468_213331_480x0_resize_box_3.png 480w, /post/56/49_huad89d34689f7791d88edb93809b3c468_213331_1024x0_resize_box_3.png 1024w" width=1724 height=970 loading=lazy></a></figure></p><ul><li>FSR 2.0 提供了可以直接链接的 Windows 库，当然同时也会在 GPU Open 开源所有的 C++ 代码，也可以在其他平台上手动编译集成。跟 FSR 1.0、NIS 比较类似，使用 SDK 可以直接获取最佳参数，然后直接传入 Shader 就可以了。</li><li>SDK 的 API 有三个主要接口，ContextCreate、ContextDestroy、ContextDispatch，然后还提供了一些接口用于获取 JitterPhaseCount、JitterOffset、RenderResolution、UpscaleRatio 等。</li></ul><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/50.png data-size=1726x968><img src=/post/56/50.png srcset="/post/56/50_hu3212cc25f5e60612fb0306b6c7b6618d_140834_480x0_resize_box_3.png 480w, /post/56/50_hu3212cc25f5e60612fb0306b6c7b6618d_140834_1024x0_resize_box_3.png 1024w" width=1726 height=968 loading=lazy></a></figure></p><p>给了一些集成的参考时间，像已经集成了 DLSS 2.0 的游戏最快只要三天就能搞定，其他集成的工作量视情况而定，最慢也只需要约 4 周左右。</p><p><figure style=flex-grow:178;flex-basis:428px><a href=/post/56/51.png data-size=1728x968><img src=/post/56/51.png srcset="/post/56/51_hu5888632d3462b1738747f80cedfb79dd_107237_480x0_resize_box_3.png 480w, /post/56/51_hu5888632d3462b1738747f80cedfb79dd_107237_1024x0_resize_box_3.png 1024w" width=1728 height=968 loading=lazy></a></figure></p><p>按照之间说的，FSR 2.0 在集成时是直接替换 TAA Stage 的，关闭 FSR 2.0 时需要打开 TAA，打开 TAA 就需要关闭 FSR 2.0。另外 FSR 2.0 还提供了一个 TAA-Only 模式，只开启 TAA 不做 Upscaling，方便直接切换。</p><p><figure style=flex-grow:178;flex-basis:429px><a href=/post/56/52.png data-size=1727x966><img src=/post/56/52.png srcset="/post/56/52_hu5b5573c0acb9a620ee3ab4ac870be968_176362_480x0_resize_box_3.png 480w, /post/56/52_hu5b5573c0acb9a620ee3ab4ac870be968_176362_1024x0_resize_box_3.png 1024w" width=1727 height=966 loading=lazy></a></figure></p><p>FSR 1.0 在一帧中的位置是后处理的最后阶段，而 FSR 2.0 不一样，它处于整个 Pipeline 比较早期的阶段。因为是替换 TAA，所以所有需要抗锯齿输入的后处理都应该放到 FSAR 2.0 后面，所有需要 Depth Buffer 的后处理都要放到 FSR 2.0 的前面。</p><p><figure style=flex-grow:177;flex-basis:427px><a href=/post/56/53.png data-size=1726x970><img src=/post/56/53.png srcset="/post/56/53_hu72456241dc5f66248a3940bef5565651_176599_480x0_resize_box_3.png 480w, /post/56/53_hu72456241dc5f66248a3940bef5565651_176599_1024x0_resize_box_3.png 1024w" width=1726 height=970 loading=lazy></a></figure></p><p>FSR 2.0 的 Buffer 输入只有当前帧的 Depth、Motion Vector、Color，不需要开发者传入任何历史帧的信息，FSR 会在内部存储上一帧的 Output Buffer。</p><p><figure style=flex-grow:178;flex-basis:428px><a href=/post/56/54.png data-size=1726x966><img src=/post/56/54.png srcset="/post/56/54_hu66190f248e205deb641dbf920689c710_260365_480x0_resize_box_3.png 480w, /post/56/54_hu66190f248e205deb641dbf920689c710_260365_1024x0_resize_box_3.png 1024w" width=1726 height=966 loading=lazy></a></figure></p><p>FSR 2.0 对 Depth Buffer 是有一定要求的，Reversed、Infinite Farplane、R32_FLOAT 精度，这样的话可以达到最佳效果，如果集成时 Depth 不能满足条件的话，也可以在创建 Context 的时候通过修改 FLags 来进行调整。</p><p><figure style=flex-grow:177;flex-basis:426px><a href=/post/56/55.png data-size=1727x972><img src=/post/56/55.png srcset="/post/56/55_hu0515409ebe0a80ffd55537da0482b13f_435499_480x0_resize_box_3.png 480w, /post/56/55_hu0515409ebe0a80ffd55537da0482b13f_435499_1024x0_resize_box_3.png 1024w" width=1727 height=972 loading=lazy></a></figure></p><p>类似的，对 Motion Vector Buffer 也有要求，需要 UV Space 的 2D Vector，是一张单独的 Buffer Resource、至少需要 R16G16 精度（R8G8 不能满足精度需求），还要就是需要保证所有的场景元素都要在 Motion Vector Resource 中。类似的 Motion Vector 也有控制的 Flags，可以根据需要调整。如果需要进行一些其他的定制（比如做一些定制化的 RT 合并）可以自行修改源码。</p><p><figure style=flex-grow:178;flex-basis:428px><a href=/post/56/56.png data-size=1731x970><img src=/post/56/56.png srcset="/post/56/56_hu01a0dda4c488eb5d886253a46c769969_463954_480x0_resize_box_3.png 480w, /post/56/56_hu01a0dda4c488eb5d886253a46c769969_463954_1024x0_resize_box_3.png 1024w" width=1731 height=970 loading=lazy></a></figure></p><p>最后是 Color Buffer，对于 LDR Pipelines，推荐使用 Linear Format 但不是必须的。对于 HDR Pipelines，输入必须是 Linear RGB，PQ / HLG 不太适合作为输入格式，另外输入颜色值不能为负数，需要 Clamp 到 0 以上。使用 HDR Pipelines 需要在创建 Context 指定对应的 Flags。另外就是自动曝光，如果需要启用自动曝光的话传入对应的 Flags 就行了，如果引擎本身就做了自动曝光的话，把对应的 Shader Resource 传入即可。</p><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/57.png data-size=1726x969><img src=/post/56/57.png srcset="/post/56/57_hu0b482bb3daf695ff265c7f95c6c1d9d8_228101_480x0_resize_box_3.png 480w, /post/56/57_hu0b482bb3daf695ff265c7f95c6c1d9d8_228101_1024x0_resize_box_3.png 1024w" width=1726 height=969 loading=lazy></a></figure></p><p>另外一项配置是 Jitter Patterns，推荐的 Jitter Patterns 是 Halton(2,3)，在 FSR 2.0 SDK 中提供了相关的接口用于获取 Jitter Offset。要注意的是 Halton 序列长度随着会 Scaling Ratio 不同而产生变化，下面是一个对照表，序列长度可以通过 ffxFsr2GetJitterPhaseCount 获取。</p><p><figure style=flex-grow:178;flex-basis:428px><a href=/post/56/58.png data-size=1729x968><img src=/post/56/58.png srcset="/post/56/58_hu8930b0fa26496d64a7c4e005880a4485_207299_480x0_resize_box_3.png 480w, /post/56/58_hu8930b0fa26496d64a7c4e005880a4485_207299_1024x0_resize_box_3.png 1024w" width=1729 height=968 loading=lazy></a></figure></p><p>DRS 可以使用 Flags 开启，上面一页我们知道 Jitter Sequence Length 会随着 Scaling Ratio 变化而变化，ffxFsr2GetJitterPhaseCount 的入参是渲染分辨率的大小，所以每一帧得到的 Jitter Sequence Length 是不同的。Jitter Phase Id 不会立即清零，等到 Id 跟 Length 相等时就会归零重新开始，这样新的 Length 就生效了。</p><p><figure style=flex-grow:177;flex-basis:427px><a href=/post/56/59.png data-size=1726x970><img src=/post/56/59.png srcset="/post/56/59_hubd13ec4857dd5908196352da925da468_621127_480x0_resize_box_3.png 480w, /post/56/59_hubd13ec4857dd5908196352da925da468_621127_1024x0_resize_box_3.png 1024w" width=1726 height=970 loading=lazy></a></figure></p><p>Mip Bias 在 Upscaling 时也是一个很重要的参数，因为以渲染分辨率渲染会导致纹理在被渲染时使用比较高的 Mip，这样再进行 Upscaling 之后就会出现失真的情况。所以我们需要计算一个负的 Mip Bias 来让纹理被采样时使用与目标分辨率匹配的 Mip。公式也很简单，就是 RenderResolution 与 DisplayResolution 的比例 - 1，右边是 Quality Mode 所对应的 Mip Bias。有一点需要注意的是表现出高频细节的纹理需要把 Mip Bias 设置成 0，否则经过 TAA 处理后会出现闪烁现象。</p><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/60.png data-size=1726x969><img src=/post/56/60.png srcset="/post/56/60_hud86fd8b37f9f0dac7288a25b572b0387_595037_480x0_resize_box_3.png 480w, /post/56/60_hud86fd8b37f9f0dac7288a25b572b0387_595037_1024x0_resize_box_3.png 1024w" width=1726 height=969 loading=lazy></a></figure></p><p>前面已经提到了，FSR 2.0 有一个可配置的锐化 Pass，叫做 RCAS，默认情况下，RCAS Pass 是关闭的（FSR 1.0 是默认开启的）。RCAS Pass 可以配置一个锐化强度参数，参数范围为 0.0 → 1.0（与 FSR 1.0 相同），在 ContextDispatch 时传入。上面两张图是开关 RCAS 的对比，可以看见右图细节明显要清晰很多。另外一点要注意的是，如果单独使用了 AMD 的 RCAS，在集成 FSR 2.0 之后需要关掉，同时只需要启用一个 RCAS Pass 即可。</p><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/61.png data-size=1729x971><img src=/post/56/61.png srcset="/post/56/61_hu0c483964bf06babf46ad414dc14550ed_133493_480x0_resize_box_3.png 480w, /post/56/61_hu0c483964bf06babf46ad414dc14550ed_133493_1024x0_resize_box_3.png 1024w" width=1729 height=971 loading=lazy></a></figure></p><p>FSR 2.0 SDK 还在 ContextDispatch 的参数中提供了一个 boolean 用于重设所有历史帧，通常用于大面积的场景切换后防鬼影，比如主场景与过场动画的切换。</p><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/62.png data-size=1728x969><img src=/post/56/62.png srcset="/post/56/62_hu3cef75741bb1df67fc9f3f2e760b1fce_138460_480x0_resize_box_3.png 480w, /post/56/62_hu3cef75741bb1df67fc9f3f2e760b1fce_138460_1024x0_resize_box_3.png 1024w" width=1728 height=969 loading=lazy></a></figure></p><p>前面说的都是 FSR 2.0 SDK 的使用方法，由于 SDK 本身是开源的，在集成时可以对 API 做各种自定义修改，比如前面提到的把 Motion Vector 跟其他 RT Pack 到一起。</p><p><figure style=flex-grow:178;flex-basis:428px><a href=/post/56/63.png data-size=1725x967><img src=/post/56/63.png srcset="/post/56/63_hufd7c9ebff3048186058622235cb42000_330665_480x0_resize_box_3.png 480w, /post/56/63_hufd7c9ebff3048186058622235cb42000_330665_1024x0_resize_box_3.png 1024w" width=1725 height=967 loading=lazy></a></figure></p><p>跟 DLSS 类似，对于 UI、各种语言的选项描述，FSR 2.0 也有一套官方的 Guidline。</p><p><figure style=flex-grow:178;flex-basis:429px><a href=/post/56/64.png data-size=1727x966><img src=/post/56/64.png srcset="/post/56/64_hu4750ca746a1e85b017dcfbca751089f4_1428959_480x0_resize_box_3.png 480w, /post/56/64_hu4750ca746a1e85b017dcfbca751089f4_1428959_1024x0_resize_box_3.png 1024w" width=1727 height=966 loading=lazy></a></figure></p><p>总结一下：</p><ul><li>FSR 2.0 相比 FSR 1.0 有着更高的质量，基于新的 TAA 算法。</li><li>FSR 2.0 提高了容易使用的 SDK，如果已经集成了 DLSS，集成 FSR 2.0 是很容易的一件事，另外 FSR 2.0 完全开源，支持各种硬件。</li><li>关注 GPU Open 的新消息。</li></ul><p><figure style=flex-grow:178;flex-basis:427px><a href=/post/56/65.png data-size=1726x969><img src=/post/56/65.png srcset="/post/56/65_hue8d80c6bbcd4194a5a5ae278c5280d6d_100364_480x0_resize_box_3.png 480w, /post/56/65_hue8d80c6bbcd4194a5a5ae278c5280d6d_100364_1024x0_resize_box_3.png 1024w" width=1726 height=969 loading=lazy></a></figure></p><p>DLSS 在 4k 下其实还是挺耗的，而 FSR 2.0 效果不错，在 4k Quality Mode 下都只需要 1ms，还能把 TAA 的开销也给省了，论集成友好度和兼容性也远好于 DLSS，看起来还是挺香的。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/gdc/>GDC</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>相关文章</h2><div class=related-contents><div class="flex article-list--tile"><article><a href=/post/57/><div class=article-details><h2 class=article-title>GDC 笔记 - Simulating Tropical Weather in FARCRY6</h2></div></a></article><article><a href=/post/53/><div class=article-details><h2 class=article-title>GDC 笔记 - Quadtree Displacement Mapping with Height Blending</h2></div></a></article><article><a href=/post/51/><div class=article-details><h2 class=article-title>GDC 笔记 - 'Ghost Recon Wildlands': Terrain Tools and Technology</h2></div></a></article><article><a href=/post/52/><div class=article-details><h2 class=article-title>GDC 笔记 - Terrain Rendering in 'Far Cry 5'</h2></div></a></article><article><a href=/post/58/><div class=article-details><h2 class=article-title>如何以酷炫的姿势造一个 C++ 动态反射轮子</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=FlyAndNotDown/KindemBlog issue-term=title crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;setUtterancesTheme(document.body.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2017 -
2023 Kindem的博客</section><section class=powerby>©2017-2021 Copyright kindem.xyz / 湘ICP备17018771号-1<br>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=2.3.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>