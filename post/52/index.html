<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="育碧 Far Cry 5 地形渲染的 Talk。"><meta name=keywords content="ubi,far cry 5,terrain,rendering"><title>GDC 笔记 - Terrain Rendering in 'Far Cry 5'</title><link rel=canonical href=https://www.kindem.xyz/post/52/><link rel=stylesheet href=/scss/style.min.css><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?a0c486208ba4751b6988ccc92f1479ee",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><meta property="og:title" content="GDC 笔记 - Terrain Rendering in 'Far Cry 5'"><meta property="og:description" content="育碧 Far Cry 5 地形渲染的 Talk。"><meta property="og:url" content="https://www.kindem.xyz/post/52/"><meta property="og:site_name" content="Kindem的博客"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="GDC"><meta property="article:published_time" content="2022-02-21T00:00:00+00:00"><meta property="article:modified_time" content="2022-02-21T00:00:00+00:00"><meta name=twitter:title content="GDC 笔记 - Terrain Rendering in 'Far Cry 5'"><meta name=twitter:description content="育碧 Far Cry 5 地形渲染的 Talk。"><link rel="shortcut icon" href=#ZgotmplZ><script async src="https://www.googletagmanager.com/gtag/js?id=G-F3YCH8P4PP"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F3YCH8P4PP",{anonymize_ip:!1})}</script></head><body><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.body.dataset.scheme="dark":document.body.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended article-page with-toolbar"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header class=site-info><figure class=site-avatar><img src=/img/avatar_hu0f5c0aa158a4e8466efa1fc48b48096f_378948_300x0_resize_q75_box.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar>
<span class=emoji>🎯</span></figure><h1 class=site-name><a href=https://www.kindem.xyz/>Kindem的博客</a></h1><h2 class=site-description>层楼终究误少年，自由早晚乱余生</h2></header><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>归档</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>搜索</span></a></li><li><a href=/friends/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg><span>友链</span></a></li><li><a href=/%E5%85%B3%E4%BA%8E/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>关于</span></a></li><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>暗色模式</span></li></ol></aside><main class="main full-width"><div id=article-toolbar><a href=https://www.kindem.xyz/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>Back</span></a></div><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E6%8A%80%E6%9C%AF/>技术</a></header><h2 class=article-title><a href=/post/52/>GDC 笔记 - Terrain Rendering in 'Far Cry 5'</a></h2><h3 class=article-subtitle>育碧 Far Cry 5 地形渲染的 Talk。</h3><footer class=article-time><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--published>Feb 21, 2022</time></footer></div></header><section class=article-content><blockquote><p>原文链接：<a class=link href=https://www.gdcvault.com/play/1025480/Terrain-Rendering-in-Far-Cry target=_blank rel=noopener>GDC Vault - Terrain Rendering in &lsquo;Far Cry 5&rsquo;</a></p></blockquote><p><figure style=flex-grow:175;flex-basis:422px><a href=/post/52/1.png data-size=1419x807><img src=/post/52/1.png srcset="/post/52/1_hu167fc3d6d491dcbb17142129add2166e_1894791_480x0_resize_box_3.png 480w, /post/52/1_hu167fc3d6d491dcbb17142129add2166e_1894791_1024x0_resize_box_3.png 1024w" width=1419 height=807 loading=lazy></a></figure></p><p>地形 Heightfield 渲染。</p><p><figure style=flex-grow:174;flex-basis:418px><a href=/post/52/2.png data-size=1382x793><img src=/post/52/2.png srcset="/post/52/2_hu746e08aaacb8a0c4c605489514cb7d08_614464_480x0_resize_box_3.png 480w, /post/52/2_hu746e08aaacb8a0c4c605489514cb7d08_614464_1024x0_resize_box_3.png 1024w" width=1382 height=793 loading=lazy></a></figure></p><p>地图大小是 10km x 10km，分辨率 0.5m，地形按照四叉树管理，整个地形被划分成 2km x 2km 的地块，这些地块永久可见。</p><p><figure style=flex-grow:175;flex-basis:422px><a href=/post/52/3.png data-size=1386x788><img src=/post/52/3.png srcset="/post/52/3_hu723c6ed4e27fa11455347b36fc227247_797633_480x0_resize_box_3.png 480w, /post/52/3_hu723c6ed4e27fa11455347b36fc227247_797633_1024x0_resize_box_3.png 1024w" width=1386 height=788 loading=lazy></a></figure></p><p>上面说的 2km x 2km 的地块被按照四叉树划分成很多 Tile，这些 Tile 按照 LOD 以及与玩家的距离进行 Steaming，磁盘上存储的 Tiles 数量上万，但是实际上运行时加载进内存的 Tiles 数量大概在 500 左右。</p><p><figure style=flex-grow:175;flex-basis:421px><a href=/post/52/4.png data-size=1382x786><img src=/post/52/4.png srcset="/post/52/4_hucbf8afa60f579a4fe7690deff6e3b733_543775_480x0_resize_box_3.png 480w, /post/52/4_hucbf8afa60f579a4fe7690deff6e3b733_543775_1024x0_resize_box_3.png 1024w" width=1382 height=786 loading=lazy></a></figure></p><p>所有四叉树节点所需要的 Textures 会同步被 Streaming 进 Texture Atlases，节点中会记录对应 Atlases 中的位置。纹理格式：</p><ul><li>Heightmap: R16_UNORM, 129x129</li><li>World space normal map: BC3, 132x132</li><li>Baked albedo map: BC1, 132x132</li></ul><p><figure style=flex-grow:176;flex-basis:423px><a href=/post/52/5.png data-size=1384x784><img src=/post/52/5.png srcset="/post/52/5_hu74ae5992151f4eaeee1234044a261fda_265662_480x0_resize_box_3.png 480w, /post/52/5_hu74ae5992151f4eaeee1234044a261fda_265662_1024x0_resize_box_3.png 1024w" width=1384 height=784 loading=lazy></a></figure></p><p>地形的渲染大概这么几步。</p><p><figure style=flex-grow:176;flex-basis:422px><a href=/post/52/6.png data-size=1387x787><img src=/post/52/6.png srcset="/post/52/6_hub65bbe7d420731607dd480432269e214_577596_480x0_resize_box_3.png 480w, /post/52/6_hub65bbe7d420731607dd480432269e214_577596_1024x0_resize_box_3.png 1024w" width=1387 height=787 loading=lazy></a></figure></p><p>首先是四叉树节点的 Streaming，首先在 LOD0 找到离玩家最近的一圈节点。</p><p><figure style=flex-grow:176;flex-basis:422px><a href=/post/52/7.png data-size=1384x786><img src=/post/52/7.png srcset="/post/52/7_hub8ac054fdb9b7956a35cca59c14d5ff8_519230_480x0_resize_box_3.png 480w, /post/52/7_hub8ac054fdb9b7956a35cca59c14d5ff8_519230_1024x0_resize_box_3.png 1024w" width=1384 height=786 loading=lazy></a></figure></p><p>切换到下一级 LOD，按更大范围找四叉树中对应的节点。</p><p><figure style=flex-grow:174;flex-basis:419px><a href=/post/52/8.png data-size=1381x791><img src=/post/52/8.png srcset="/post/52/8_hu0abf71afa92c46f602afaf866cede4af_468069_480x0_resize_box_3.png 480w, /post/52/8_hu0abf71afa92c46f602afaf866cede4af_468069_1024x0_resize_box_3.png 1024w" width=1381 height=791 loading=lazy></a></figure></p><p>以此类推，直到最后一级 LOD，前面说到了，最后一级 LOD 对应的四叉树节点是永远被加载的。这里只演示了 3 级 LOD，实际上 Far Cry 5 里有 6 级。</p><p><figure style=flex-grow:176;flex-basis:422px><a href=/post/52/9.png data-size=1381x784><img src=/post/52/9.png srcset="/post/52/9_hu165835951e8b776715d3b60ba8f9438f_659093_480x0_resize_box_3.png 480w, /post/52/9_hu165835951e8b776715d3b60ba8f9438f_659093_1024x0_resize_box_3.png 1024w" width=1381 height=784 loading=lazy></a></figure></p><p><figure style=flex-grow:176;flex-basis:424px><a href=/post/52/10.png data-size=1383x782><img src=/post/52/10.png srcset="/post/52/10_hu1d6373430111ef258f750c0605f0493a_438540_480x0_resize_box_3.png 480w, /post/52/10_hu1d6373430111ef258f750c0605f0493a_438540_1024x0_resize_box_3.png 1024w" width=1383 height=782 loading=lazy></a></figure></p><p>最后组合起来，就是需要 Streaming 的所有节点。</p><p><figure style=flex-grow:176;flex-basis:424px><a href=/post/52/11.png data-size=1384x782><img src=/post/52/11.png srcset="/post/52/11_hu325b47bde0ab62bfaf0ed598b8cca292_471605_480x0_resize_box_3.png 480w, /post/52/11_hu325b47bde0ab62bfaf0ed598b8cca292_471605_1024x0_resize_box_3.png 1024w" width=1384 height=782 loading=lazy></a></figure></p><p><figure style=flex-grow:176;flex-basis:423px><a href=/post/52/12.png data-size=1376x780><img src=/post/52/12.png srcset="/post/52/12_hu83494a0d0f70acfc13b0fe59fe608f45_476575_480x0_resize_box_3.png 480w, /post/52/12_hu83494a0d0f70acfc13b0fe59fe608f45_476575_1024x0_resize_box_3.png 1024w" width=1376 height=780 loading=lazy></a></figure></p><p>然后需要按照视角做剔除。</p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/13.png data-size=1376x786><img src=/post/52/13.png srcset="/post/52/13_hu6be225fce6f060b5c066c07499704dc6_517110_480x0_resize_box_3.png 480w, /post/52/13_hu6be225fce6f060b5c066c07499704dc6_517110_1024x0_resize_box_3.png 1024w" width=1376 height=786 loading=lazy></a></figure></p><p>接下来需要按照离相机的距离做一次 Batch，同一组的节点使用相同的 Shader，距离越远，使用的 Shader 越简单。</p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/14.png data-size=1381x789><img src=/post/52/14.png srcset="/post/52/14_hu5c0b4dde01774964e1a3add051517da6_310502_480x0_resize_box_3.png 480w, /post/52/14_hu5c0b4dde01774964e1a3add051517da6_310502_1024x0_resize_box_3.png 1024w" width=1381 height=789 loading=lazy></a></figure></p><p><figure style=flex-grow:175;flex-basis:421px><a href=/post/52/15.png data-size=1379x785><img src=/post/52/15.png srcset="/post/52/15_hudc26ac4c591a28b5e04096370cfaae19_327014_480x0_resize_box_3.png 480w, /post/52/15_hudc26ac4c591a28b5e04096370cfaae19_327014_1024x0_resize_box_3.png 1024w" width=1379 height=785 loading=lazy></a></figure></p><p>上面的渲染流程可以用 CPU 实现，也可以走 GPU-Driven 路线，区别就是下面这部分在哪做。</p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/16.png data-size=1380x787><img src=/post/52/16.png srcset="/post/52/16_hu3371208a70eaa8469817ca366a3314b8_121489_480x0_resize_box_3.png 480w, /post/52/16_hu3371208a70eaa8469817ca366a3314b8_121489_1024x0_resize_box_3.png 1024w" width=1380 height=787 loading=lazy></a></figure></p><p>GPU-Driven 的优势，BalaBala &mldr;&mldr;</p><p><figure style=flex-grow:174;flex-basis:418px><a href=/post/52/17.png data-size=1385x794><img src=/post/52/17.png srcset="/post/52/17_hu05323ec2cca6fb167ad0d2020b0e0901_176632_480x0_resize_box_3.png 480w, /post/52/17_hu05323ec2cca6fb167ad0d2020b0e0901_176632_1024x0_resize_box_3.png 1024w" width=1385 height=794 loading=lazy></a></figure></p><p>需要的 GPU 数据结构及特点。</p><p><figure style=flex-grow:175;flex-basis:421px><a href=/post/52/18.png data-size=1375x783><img src=/post/52/18.png srcset="/post/52/18_hu9dbd72d66e9c560eecaccd6b5a453d7f_503848_480x0_resize_box_3.png 480w, /post/52/18_hu9dbd72d66e9c560eecaccd6b5a453d7f_503848_1024x0_resize_box_3.png 1024w" width=1375 height=783 loading=lazy></a></figure></p><p>四叉树对应的 GPU 实现就是带 Mips 的纹理，Terrain Quad Tree 也是一样，是一张 160x160 的纹理，整个纹理有 6 级 Mips，每个节点对应纹理中的一个 Texel。</p><p><figure style=flex-grow:176;flex-basis:423px><a href=/post/52/19.png data-size=1388x786><img src=/post/52/19.png srcset="/post/52/19_hu4b645987f0c23c97dc8ba80985dd7487_630401_480x0_resize_box_3.png 480w, /post/52/19_hu4b645987f0c23c97dc8ba80985dd7487_630401_1024x0_resize_box_3.png 1024w" width=1388 height=786 loading=lazy></a></figure></p><p>Terrain Quad Tree 纹理的格式是 R16_UINT，存的是 16 位的 Index，用于索引保存在 Node Description Buffer 的真正的节点数据，Node Description Buffer 中的每个节点数据保存了 Min/Max Height、LOD Bias、Atlas ID 等信息，最终按位编码成 2 个 Uint。</p><p><figure style=flex-grow:175;flex-basis:422px><a href=/post/52/20.png data-size=1383x786><img src=/post/52/20.png srcset="/post/52/20_hu4256001632d03413cb4d8e64ba9052e4_672150_480x0_resize_box_3.png 480w, /post/52/20_hu4256001632d03413cb4d8e64ba9052e4_672150_1024x0_resize_box_3.png 1024w" width=1383 height=786 loading=lazy></a></figure></p><p>每当节点 Streaming In / Out 的时候，需要对 Node Description Buffer 里的数据进行填充 / 移除。</p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/21.png data-size=1380x787><img src=/post/52/21.png srcset="/post/52/21_hu0961ff4cb0440f05b625ee481b8d0f29_151029_480x0_resize_box_3.png 480w, /post/52/21_hu0961ff4cb0440f05b625ee481b8d0f29_151029_1024x0_resize_box_3.png 1024w" width=1380 height=787 loading=lazy></a></figure></p><p>Terrain Node List 就是一个节点 Id 的列表，表示可能被渲染的节点（剔除前）。Terrain Node List 需要每一帧遍历 Terrain Quad Tree 来生成。</p><p><figure style=flex-grow:176;flex-basis:423px><a href=/post/52/22.png data-size=1386x786><img src=/post/52/22.png srcset="/post/52/22_hua7351750c7fb525b9f95674c2b997fac_141677_480x0_resize_box_3.png 480w, /post/52/22_hua7351750c7fb525b9f95674c2b997fac_141677_1024x0_resize_box_3.png 1024w" width=1386 height=786 loading=lazy></a></figure></p><p>Terrain Node List 的生成使用 Compute Shader，分为多个 Stage，每个 Stage 处理一级 LOD，每个 Stage 中由一个线程来处理当前 LOD 的一个节点，将其划分成子节点，填充到 Terrain Node List 中。</p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/23.png data-size=1386x792><img src=/post/52/23.png srcset="/post/52/23_hu6cf6b5a771f69d5147ca6cb9f2c1b3cb_565194_480x0_resize_box_3.png 480w, /post/52/23_hu6cf6b5a771f69d5147ca6cb9f2c1b3cb_565194_1024x0_resize_box_3.png 1024w" width=1386 height=792 loading=lazy></a></figure></p><p>Terrain Node List 的初始状态是用 LOD 0 计算，直接根据当前 Terrain Quad Tree 的 Mip 0 计算出一组 NodeID。</p><p><figure style=flex-grow:177;flex-basis:425px><a href=/post/52/24.png data-size=1395x787><img src=/post/52/24.png srcset="/post/52/24_huea477011c33336a2117a5d0f38ce45b5_608734_480x0_resize_box_3.png 480w, /post/52/24_huea477011c33336a2117a5d0f38ce45b5_608734_1024x0_resize_box_3.png 1024w" width=1395 height=787 loading=lazy></a></figure></p><p><figure style=flex-grow:175;flex-basis:422px><a href=/post/52/25.png data-size=1379x784><img src=/post/52/25.png srcset="/post/52/25_huac829cb7a490831e6c3c036573a9e253_607516_480x0_resize_box_3.png 480w, /post/52/25_huac829cb7a490831e6c3c036573a9e253_607516_1024x0_resize_box_3.png 1024w" width=1379 height=784 loading=lazy></a></figure></p><p><figure style=flex-grow:176;flex-basis:422px><a href=/post/52/26.png data-size=1379x783><img src=/post/52/26.png srcset="/post/52/26_hue31b95bc138d16addbd185cd993afa81_623595_480x0_resize_box_3.png 480w, /post/52/26_hue31b95bc138d16addbd185cd993afa81_623595_1024x0_resize_box_3.png 1024w" width=1379 height=783 loading=lazy></a></figure></p><p><figure style=flex-grow:176;flex-basis:424px><a href=/post/52/27.png data-size=1380x781><img src=/post/52/27.png srcset="/post/52/27_hudb294db9078ad4552c5274178bd17140_670914_480x0_resize_box_3.png 480w, /post/52/27_hudb294db9078ad4552c5274178bd17140_670914_1024x0_resize_box_3.png 1024w" width=1380 height=781 loading=lazy></a></figure></p><p>进入下一个 Stage，读取上一个 Stage 的结果（Temp A），构造两个新的 Buffer，Temp B 和 Final，如果上一级 Mip 中的节点可以被细分（在这一级 Mip 中四个子节点被完全加载）就将其细分成 4 个节点，并存入 Temp B，如果不能被细分就直接放入 Final。</p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/28.png data-size=1374x785><img src=/post/52/28.png srcset="/post/52/28_hud874ea3bec8909f6cfe8faa1cf5f9a07_681032_480x0_resize_box_3.png 480w, /post/52/28_hud874ea3bec8909f6cfe8faa1cf5f9a07_681032_1024x0_resize_box_3.png 1024w" width=1374 height=785 loading=lazy></a></figure></p><p>有些节点的子节点没有被完全加载，这种也直接放入 Final。</p><p><figure style=flex-grow:175;flex-basis:422px><a href=/post/52/29.png data-size=1381x785><img src=/post/52/29.png srcset="/post/52/29_hu1760fe886ee675cf68aacc924c2450b5_776227_480x0_resize_box_3.png 480w, /post/52/29_hu1760fe886ee675cf68aacc924c2450b5_776227_1024x0_resize_box_3.png 1024w" width=1381 height=785 loading=lazy></a></figure></p><p><figure style=flex-grow:176;flex-basis:423px><a href=/post/52/30.png data-size=1383x784><img src=/post/52/30.png srcset="/post/52/30_hu28830f62559cb6dbc0ae1ac4932b6230_782616_480x0_resize_box_3.png 480w, /post/52/30_hu28830f62559cb6dbc0ae1ac4932b6230_782616_1024x0_resize_box_3.png 1024w" width=1383 height=784 loading=lazy></a></figure></p><p><figure style=flex-grow:176;flex-basis:424px><a href=/post/52/31.png data-size=1376x778><img src=/post/52/31.png srcset="/post/52/31_hu0733861c4304f55de039e083c362a64e_825496_480x0_resize_box_3.png 480w, /post/52/31_hu0733861c4304f55de039e083c362a64e_825496_1024x0_resize_box_3.png 1024w" width=1376 height=778 loading=lazy></a></figure></p><p><figure style=flex-grow:175;flex-basis:422px><a href=/post/52/32.png data-size=1377x783><img src=/post/52/32.png srcset="/post/52/32_hu1d0c967774a88165aeee4c0562533933_839294_480x0_resize_box_3.png 480w, /post/52/32_hu1d0c967774a88165aeee4c0562533933_839294_1024x0_resize_box_3.png 1024w" width=1377 height=783 loading=lazy></a></figure></p><p>清空 Temp A，交换一下 Temp A 和 Temp B 的角色，进入下一个 Stage。</p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/33.png data-size=1369x782><img src=/post/52/33.png srcset="/post/52/33_hu7f4ee47506352e2c237e1633311cceae_99388_480x0_resize_box_3.png 480w, /post/52/33_hu7f4ee47506352e2c237e1633311cceae_99388_1024x0_resize_box_3.png 1024w" width=1369 height=782 loading=lazy></a></figure></p><p>以此类推完成 Terrain Node List 的生成。每个 Pass 对应一个 Stage，每个 Pass 需要两次 Compute Shader 的 Dispatch，因为需要统计每个 LOD 中节点的数量，来 Feed 下一个 Pass。</p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/34.png data-size=1375x784><img src=/post/52/34.png srcset="/post/52/34_hudd3db8048f5ac80cfa5adb44ad8a8494_515808_480x0_resize_box_3.png 480w, /post/52/34_hudd3db8048f5ac80cfa5adb44ad8a8494_515808_1024x0_resize_box_3.png 1024w" width=1375 height=784 loading=lazy></a></figure></p><p>每一帧都要计算一个 160x160 的 Terrain LOD Map 纹理，格式为 R8，每个 Texel 代表一个 Sector，保存了这个 Sector 对应的 LOD。这张纹理的作用是用于处理不同 LOD 之间的接缝。这里有些部分为 0 是因为 Sector 为空，不是 LOD 0。</p><p><figure style=flex-grow:174;flex-basis:419px><a href=/post/52/35.png data-size=1380x789><img src=/post/52/35.png srcset="/post/52/35_hua11b5bb3d56cb5be8c6ad1842e8cc38d_653165_480x0_resize_box_3.png 480w, /post/52/35_hua11b5bb3d56cb5be8c6ad1842e8cc38d_653165_1024x0_resize_box_3.png 1024w" width=1380 height=789 loading=lazy></a></figure></p><p><figure style=flex-grow:175;flex-basis:421px><a href=/post/52/36.png data-size=1384x788><img src=/post/52/36.png srcset="/post/52/36_hu05f80e86b59b884920cbafafe13f8494_684534_480x0_resize_box_3.png 480w, /post/52/36_hu05f80e86b59b884920cbafafe13f8494_684534_1024x0_resize_box_3.png 1024w" width=1384 height=788 loading=lazy></a></figure></p><p>计算 Terrain LOD Group 的方法也很简单，拿着 Terrain Node List 直接照填就行了。</p><p><figure style=flex-grow:176;flex-basis:422px><a href=/post/52/37.png data-size=1376x781><img src=/post/52/37.png srcset="/post/52/37_hu05204716a2ea8ab397f3f1ab4c4a275c_234795_480x0_resize_box_3.png 480w, /post/52/37_hu05204716a2ea8ab397f3f1ab4c4a275c_234795_1024x0_resize_box_3.png 1024w" width=1376 height=781 loading=lazy></a></figure></p><p>最后是 Visible Render Patch List，由一个 Indirect Args 和一组 Patch 构成，Patch 里保存了 Draw 所需要的信息。最终下发 DrawCall 后每个 Patch 会被渲染成一个 16x16 的 Grid。Visible Render Patch List 的生成就是拿着 Terrain Node List 继续做细分与剔除，最终完成。</p><p><figure style=flex-grow:174;flex-basis:418px><a href=/post/52/38.png data-size=1379x791><img src=/post/52/38.png srcset="/post/52/38_hu14e37a2ffadd608261a7e648a273f9ab_176935_480x0_resize_box_3.png 480w, /post/52/38_hu14e37a2ffadd608261a7e648a273f9ab_176935_1024x0_resize_box_3.png 1024w" width=1379 height=791 loading=lazy></a></figure></p><p>每个节点会被细分成 8x8 个 Patch，每个 Patch 会被渲染成 16x16 的 Grid。每个 Compute Shader 线程负责处理一个 Patch，其中每个 Patch 都要做视椎体剔除、遮挡剔除、背面剔除、计算 LOD 过渡。</p><p><figure style=flex-grow:174;flex-basis:419px><a href=/post/52/39.png data-size=1378x788><img src=/post/52/39.png srcset="/post/52/39_huaf0f521db5f943da0ca3c6f8e0721719_363646_480x0_resize_box_3.png 480w, /post/52/39_huaf0f521db5f943da0ca3c6f8e0721719_363646_1024x0_resize_box_3.png 1024w" width=1378 height=788 loading=lazy></a></figure></p><p>Culling 的步骤与 SIGGRAPH 2015 的一篇文章 GPU-Driven Rendering Pipelines 里面介绍的类似。</p><p><figure style=flex-grow:176;flex-basis:422px><a href=/post/52/40.png data-size=1376x781><img src=/post/52/40.png srcset="/post/52/40_hu6bd81e2f11c64ab9b182a73c2385f2cd_136571_480x0_resize_box_3.png 480w, /post/52/40_hu6bd81e2f11c64ab9b182a73c2385f2cd_136571_1024x0_resize_box_3.png 1024w" width=1376 height=781 loading=lazy></a></figure></p><p>遮挡剔除用的是一个低分辨率的深度 Buffer，即 Conservative Depth，主机上和 PC 上的来源不同。</p><p><figure style=flex-grow:175;flex-basis:421px><a href=/post/52/41.png data-size=1372x782><img src=/post/52/41.png srcset="/post/52/41_hu6c3fafb4a7548e7e827852906f285ff6_68528_480x0_resize_box_3.png 480w, /post/52/41_hu6c3fafb4a7548e7e827852906f285ff6_68528_1024x0_resize_box_3.png 1024w" width=1372 height=782 loading=lazy></a></figure></p><p>生成 Mips 来适应不同大小的物体。</p><p><figure style=flex-grow:177;flex-basis:426px><a href=/post/52/42.png data-size=1383x779><img src=/post/52/42.png srcset="/post/52/42_hufa1db7fbaadb46fce6067e3f0660e319_84415_480x0_resize_box_3.png 480w, /post/52/42_hufa1db7fbaadb46fce6067e3f0660e319_84415_1024x0_resize_box_3.png 1024w" width=1383 height=779 loading=lazy></a></figure></p><p>对每一个 Patch，首先要拿到它的包围盒，然后投影到屏幕空间，在级联 Mips 中找到覆盖了这个范围的采样点，然后进行保守的剔除。</p><p><figure style=flex-grow:176;flex-basis:422px><a href=/post/52/43.png data-size=1375x781><img src=/post/52/43.png srcset="/post/52/43_hu72ca049bd15edaec15fee981106d4c7c_241414_480x0_resize_box_3.png 480w, /post/52/43_hu72ca049bd15edaec15fee981106d4c7c_241414_1024x0_resize_box_3.png 1024w" width=1375 height=781 loading=lazy></a></figure></p><p>背面剔除需要离线生成一张 8x8 BC3 的 Patch Cone Texture，每个节点 Build 一张这个纹理。对每一个 Patch，先对每一个三角形找到其 World Space 下的 Normal，然后对这些 Normal 在球面空间计算出一个最小的圈，从而形成一个 Cone。Cone 最终体现成中心的一根 Normal 向量和一个半角，被保存到 Patch Cone Texture 的一个 Texel 中。</p><p><figure style=flex-grow:176;flex-basis:423px><a href=/post/52/44.png data-size=1375x779><img src=/post/52/44.png srcset="/post/52/44_hu866e566bb71ece922d68f2325ef0bd2a_182595_480x0_resize_box_3.png 480w, /post/52/44_hu866e566bb71ece922d68f2325ef0bd2a_182595_1024x0_resize_box_3.png 1024w" width=1375 height=779 loading=lazy></a></figure></p><p>对每一个 Patch，按照上面的公式来计算是否要被剔除，保守起见，不光要拿相机方向做这个判断，还需要拿相机到 Patch 四个角的四个向量做计算，防止误剔除。</p><p><figure style=flex-grow:176;flex-basis:423px><a href=/post/52/45.png data-size=1376x779><img src=/post/52/45.png srcset="/post/52/45_hu8cbcbf123f8a3420c987579c6636f21c_97394_480x0_resize_box_3.png 480w, /post/52/45_hu8cbcbf123f8a3420c987579c6636f21c_97394_1024x0_resize_box_3.png 1024w" width=1376 height=779 loading=lazy></a></figure></p><p>每个 Patch Description 中包含了一个 LOD Transitions 信息，这个信息是当前 Patch 四个方向上与相邻 Patch 的 LOD 差值，由采样 LOD map 得到。</p><p><figure style=flex-grow:176;flex-basis:424px><a href=/post/52/46.png data-size=1378x779><img src=/post/52/46.png srcset="/post/52/46_hua0be2363ad09a570d83abfde848f73ff_145687_480x0_resize_box_3.png 480w, /post/52/46_hua0be2363ad09a570d83abfde848f73ff_145687_1024x0_resize_box_3.png 1024w" width=1378 height=779 loading=lazy></a></figure></p><p>上面这些步骤的计算时间。</p><p><figure style=flex-grow:175;flex-basis:421px><a href=/post/52/47.png data-size=1375x782><img src=/post/52/47.png srcset="/post/52/47_huac24a2c4be6a035beea7350ae2049c54_180241_480x0_resize_box_3.png 480w, /post/52/47_huac24a2c4be6a035beea7350ae2049c54_180241_1024x0_resize_box_3.png 1024w" width=1375 height=782 loading=lazy></a></figure></p><p>Vertex Shading。</p><p><figure style=flex-grow:176;flex-basis:422px><a href=/post/52/48.png data-size=1377x782><img src=/post/52/48.png srcset="/post/52/48_hu3038e09e1aa21898c6cc4c452286e895_435564_480x0_resize_box_3.png 480w, /post/52/48_hu3038e09e1aa21898c6cc4c452286e895_435564_1024x0_resize_box_3.png 1024w" width=1377 height=782 loading=lazy></a></figure></p><p>不同 LOD Mesh 之前需要额外处理接缝。</p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/49.png data-size=1374x784><img src=/post/52/49.png srcset="/post/52/49_hu8e60f9fa8b5daefb6dcfb1699e25e634_127146_480x0_resize_box_3.png 480w, /post/52/49_hu8e60f9fa8b5daefb6dcfb1699e25e634_127146_1024x0_resize_box_3.png 1024w" width=1374 height=784 loading=lazy></a></figure></p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/50.png data-size=1374x784><img src=/post/52/50.png srcset="/post/52/50_hu6c84d62a554aa311106f8a28b982b4bc_128355_480x0_resize_box_3.png 480w, /post/52/50_hu6c84d62a554aa311106f8a28b982b4bc_128355_1024x0_resize_box_3.png 1024w" width=1374 height=784 loading=lazy></a></figure></p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/51.png data-size=1372x783><img src=/post/52/51.png srcset="/post/52/51_hu0577ff6faea660cac587ec40bba36503_127105_480x0_resize_box_3.png 480w, /post/52/51_hu0577ff6faea660cac587ec40bba36503_127105_1024x0_resize_box_3.png 1024w" width=1372 height=783 loading=lazy></a></figure></p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/52.png data-size=1378x786><img src=/post/52/52.png srcset="/post/52/52_huaf8598f9afd46dbaf18689222a0c3973_127840_480x0_resize_box_3.png 480w, /post/52/52_huaf8598f9afd46dbaf18689222a0c3973_127840_1024x0_resize_box_3.png 1024w" width=1378 height=786 loading=lazy></a></figure></p><p><figure style=flex-grow:175;flex-basis:421px><a href=/post/52/53.png data-size=1376x784><img src=/post/52/53.png srcset="/post/52/53_hu66c2ef6728ededefd68cc9ccf36ef9d2_126427_480x0_resize_box_3.png 480w, /post/52/53_hu66c2ef6728ededefd68cc9ccf36ef9d2_126427_1024x0_resize_box_3.png 1024w" width=1376 height=784 loading=lazy></a></figure></p><p>前面已经说过 Patch 中保存了相邻 Patch 的 LOD 差值，可以利用这一点来进行处理。上面几张图是 LOD 差值为 1 的情况，两个顶点一组，把第二个顶点直接移动到第一个顶点的位置，从而达到过渡的目的。</p><p><figure style=flex-grow:176;flex-basis:422px><a href=/post/52/54.png data-size=1373x780><img src=/post/52/54.png srcset="/post/52/54_huff1c1776dc9d8a3813d3ceea7db3723c_101347_480x0_resize_box_3.png 480w, /post/52/54_huff1c1776dc9d8a3813d3ceea7db3723c_101347_1024x0_resize_box_3.png 1024w" width=1373 height=780 loading=lazy></a></figure></p><p><figure style=flex-grow:176;flex-basis:423px><a href=/post/52/55.png data-size=1374x779><img src=/post/52/55.png srcset="/post/52/55_hu79af9374a2e7264d6b7e222adf72417e_104683_480x0_resize_box_3.png 480w, /post/52/55_hu79af9374a2e7264d6b7e222adf72417e_104683_1024x0_resize_box_3.png 1024w" width=1374 height=779 loading=lazy></a></figure></p><p><figure style=flex-grow:176;flex-basis:423px><a href=/post/52/56.png data-size=1372x777><img src=/post/52/56.png srcset="/post/52/56_hu084dd1e019b9eb6e69d64da40968f2f6_106043_480x0_resize_box_3.png 480w, /post/52/56_hu084dd1e019b9eb6e69d64da40968f2f6_106043_1024x0_resize_box_3.png 1024w" width=1372 height=777 loading=lazy></a></figure></p><p>差值为 2 的情况下，一次处理四个顶点，后三个顶点全部移动到第一个顶点的位置。</p><p><figure style=flex-grow:176;flex-basis:423px><a href=/post/52/57.png data-size=1370x777><img src=/post/52/57.png srcset="/post/52/57_huc4b86eb37ae4122241492e59943f03be_1057298_480x0_resize_box_3.png 480w, /post/52/57_huc4b86eb37ae4122241492e59943f03be_1057298_1024x0_resize_box_3.png 1024w" width=1370 height=777 loading=lazy></a></figure></p><p>Far Cry 5 里有地形挖洞的需求，实现是存了 1Bit 的挖洞数据在 BC1 的 Atlas Albedo Map 里。</p><p><figure style=flex-grow:176;flex-basis:422px><a href=/post/52/58.png data-size=1377x782><img src=/post/52/58.png srcset="/post/52/58_hub6f5b3dcc46a2e84115ef46e71b251ca_102201_480x0_resize_box_3.png 480w, /post/52/58_hub6f5b3dcc46a2e84115ef46e71b251ca_102201_1024x0_resize_box_3.png 1024w" width=1377 height=782 loading=lazy></a></figure></p><p>通过在 Vertex Shader 里输出 NaN 来完成 Vertex 的 Cull，号称这样更省点。</p><p><figure style=flex-grow:176;flex-basis:423px><a href=/post/52/59.png data-size=1370x777><img src=/post/52/59.png srcset="/post/52/59_huc60116d7ca9759350c384077de1c1f8e_203373_480x0_resize_box_3.png 480w, /post/52/59_huc60116d7ca9759350c384077de1c1f8e_203373_1024x0_resize_box_3.png 1024w" width=1370 height=777 loading=lazy></a></figure></p><p><figure style=flex-grow:175;flex-basis:421px><a href=/post/52/60.png data-size=1381x786><img src=/post/52/60.png srcset="/post/52/60_hu02fb5023335a4285c90aa0ab364ed89f_84243_480x0_resize_box_3.png 480w, /post/52/60_hu02fb5023335a4285c90aa0ab364ed89f_84243_1024x0_resize_box_3.png 1024w" width=1381 height=786 loading=lazy></a></figure></p><p>干掉一个点会影响周围 8 个点，所以开洞的分辨率是地形分辨率的一半，即 1M。</p><p><figure style=flex-grow:175;flex-basis:421px><a href=/post/52/61.png data-size=1416x807><img src=/post/52/61.png srcset="/post/52/61_hu9ef6be56b86f66d52034f4e4dfea9964_1854607_480x0_resize_box_3.png 480w, /post/52/61_hu9ef6be56b86f66d52034f4e4dfea9964_1854607_1024x0_resize_box_3.png 1024w" width=1416 height=807 loading=lazy></a></figure></p><p>Shading，主要讲地表渲染。</p><p><figure style=flex-grow:175;flex-basis:421px><a href=/post/52/62.png data-size=1375x783><img src=/post/52/62.png srcset="/post/52/62_huec39bc6a80b4d3f22bd4f638ac129bcc_1270530_480x0_resize_box_3.png 480w, /post/52/62_huec39bc6a80b4d3f22bd4f638ac129bcc_1270530_1024x0_resize_box_3.png 1024w" width=1375 height=783 loading=lazy></a></figure></p><p>Terrain Shading 跟 2017 GDC 上的 Ghost Recon 分享类似。</p><p><figure style=flex-grow:175;flex-basis:421px><a href=/post/52/63.png data-size=1379x785><img src=/post/52/63.png srcset="/post/52/63_hu733282c94d98d48803d75a13460f8bf3_516203_480x0_resize_box_3.png 480w, /post/52/63_hu733282c94d98d48803d75a13460f8bf3_516203_1024x0_resize_box_3.png 1024w" width=1379 height=785 loading=lazy></a></figure></p><p>之前说的 Terrain Quad Tree 是带着 Texture Payload 的，他们分别是 Height、Normal、Albedo、Patch Cone Map、Color Modulation Map、Splat Map。</p><p><figure style=flex-grow:175;flex-basis:422px><a href=/post/52/64.png data-size=1374x781><img src=/post/52/64.png srcset="/post/52/64_hu458af3a5588bc0b63cbc618325017223_543423_480x0_resize_box_3.png 480w, /post/52/64_hu458af3a5588bc0b63cbc618325017223_543423_1024x0_resize_box_3.png 1024w" width=1374 height=781 loading=lazy></a></figure></p><p>远处的 Shading 可以直接用 Normal、Albedo 搞定，近处的用 Splat Map（就是我们常说的 IdMap）。Splat Map 保存了一个 8-Bit 的 Id，索引了 Material Buffer 中的一个单位，里面保存了地表的 Albedo、Normal、Height 等纹理在 Texture Array 中的索引，以及 Rotation、Tiling、Burning 等一些其他参数。</p><p>这里要注意的是 Splat Map 的位宽是 8，意味着最多可以有 256 种地表材质，但是这些材质的纹理是不可能全部加载进内存的，这些地表材质的纹理会动态地被拼成 32 层的 Texture Array 加载进内存，然后再按照 Material Buffer 中保存的 Id 进行索引，所以这意味着一个地形节点最多使用 32 种地表材质。</p><p><figure style=flex-grow:176;flex-basis:423px><a href=/post/52/65.png data-size=1377x781><img src=/post/52/65.png srcset="/post/52/65_hu40ca3f2c320f0fd57cf41fda66a335db_529380_480x0_resize_box_3.png 480w, /post/52/65_hu40ca3f2c320f0fd57cf41fda66a335db_529380_1024x0_resize_box_3.png 1024w" width=1377 height=781 loading=lazy></a></figure></p><p>经典的 IdMap 地表渲染，先拿 World Position 算 UV，然后采样 Splat Map 找到材质参数，然后采样 Texture Array 完成渲染。</p><p><figure style=flex-grow:175;flex-basis:422px><a href=/post/52/66.png data-size=1376x782><img src=/post/52/66.png srcset="/post/52/66_hu03ff8aadf0bb46640c9930046e0368bb_122628_480x0_resize_box_3.png 480w, /post/52/66_hu03ff8aadf0bb46640c9930046e0368bb_122628_1024x0_resize_box_3.png 1024w" width=1376 height=782 loading=lazy></a></figure></p><p>IdMap 算法使用的是双线性插值，所以一个点需要进行 4 次 Splat Map 的采样，然后还要采 3x4 次 Texture Array，所以最终是 16 次采样。</p><p><figure style=flex-grow:176;flex-basis:423px><a href=/post/52/67.png data-size=1373x779><img src=/post/52/67.png srcset="/post/52/67_huff3a329ff8787ccafd47fc2755b285ee_1108716_480x0_resize_box_3.png 480w, /post/52/67_huff3a329ff8787ccafd47fc2755b285ee_1108716_1024x0_resize_box_3.png 1024w" width=1373 height=779 loading=lazy></a></figure></p><p>16 次采样还是略微昂贵了点，Far Cry 5 也像 Far Cry 4 一样用了 Virtual Texture（对应 UE 里的 Runtime Virtual texture）来缓存。</p><p><figure style=flex-grow:175;flex-basis:421px><a href=/post/52/68.png data-size=1379x785><img src=/post/52/68.png srcset="/post/52/68_huc762f69ad0ab114b4b35c1ab20bc9731_394901_480x0_resize_box_3.png 480w, /post/52/68_huc762f69ad0ab114b4b35c1ab20bc9731_394901_1024x0_resize_box_3.png 1024w" width=1379 height=785 loading=lazy></a></figure></p><p>一些参数信息。</p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/69.png data-size=1374x784><img src=/post/52/69.png srcset="/post/52/69_hu21344aaa0c6a047faeda794a434d96fc_58323_480x0_resize_box_3.png 480w, /post/52/69_hu21344aaa0c6a047faeda794a434d96fc_58323_1024x0_resize_box_3.png 1024w" width=1374 height=784 loading=lazy></a></figure></p><p>可以把采样数降低到 4 次（不算 Physical Texture 更新）。</p><p><figure style=flex-grow:174;flex-basis:419px><a href=/post/52/70.png data-size=1381x791><img src=/post/52/70.png srcset="/post/52/70_hu87a7d9c16666879616723691a0fa12a0_278403_480x0_resize_box_3.png 480w, /post/52/70_hu87a7d9c16666879616723691a0fa12a0_278403_1024x0_resize_box_3.png 1024w" width=1381 height=791 loading=lazy></a></figure></p><p>一些 Physical Texture Page 渲染的参数，一帧计划最多更新 6 个 Page。每个 Page 大小为 256x256 Texel，还有 4 Texel 的 Border。跟主流做法一样，还会用 Compute Shader 做一次 BC 格式的异步压缩，最终算下来 GPU 开销大概是每帧 1ms。</p><p><figure style=flex-grow:176;flex-basis:423px><a href=/post/52/71.png data-size=1373x779><img src=/post/52/71.png srcset="/post/52/71_hud2bcb065472e60c4e8ae1c47f957cb69_90017_480x0_resize_box_3.png 480w, /post/52/71_hud2bcb065472e60c4e8ae1c47f957cb69_90017_1024x0_resize_box_3.png 1024w" width=1373 height=779 loading=lazy></a></figure></p><p>为了计算哪些 Page 需要更新，回读 PageId 到 CPU 是必不可少的，为了保持速度够快，限制了 RT 的大小。</p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/72.png data-size=1376x786><img src=/post/52/72.png srcset="/post/52/72_hu52ab47b1aab909b6d1cdada24a077bf0_1077469_480x0_resize_box_3.png 480w, /post/52/72_hu52ab47b1aab909b6d1cdada24a077bf0_1077469_1024x0_resize_box_3.png 1024w" width=1376 height=786 loading=lazy></a></figure></p><p>使用 VT 的一大好处就是方便多种材质混合，上图中就有 Road、Decal、Terrain 几种材质。</p><p><figure style=flex-grow:175;flex-basis:421px><a href=/post/52/73.png data-size=1375x783><img src=/post/52/73.png srcset="/post/52/73_hu389fe61010a7e57da5848d340977ae83_728922_480x0_resize_box_3.png 480w, /post/52/73_hu389fe61010a7e57da5848d340977ae83_728922_1024x0_resize_box_3.png 1024w" width=1375 height=783 loading=lazy></a></figure></p><p>这是一个 Overdraw 的可视化，可以看到 decal 的开销还行。</p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/74.png data-size=1409x805><img src=/post/52/74.png srcset="/post/52/74_hua0a1f483f8ad90ca76278c24621232e0_1868082_480x0_resize_box_3.png 480w, /post/52/74_hua0a1f483f8ad90ca76278c24621232e0_1868082_1024x0_resize_box_3.png 1024w" width=1409 height=805 loading=lazy></a></figure></p><p>崖壁的渲染。</p><p><figure style=flex-grow:176;flex-basis:422px><a href=/post/52/75.png data-size=1377x782><img src=/post/52/75.png srcset="/post/52/75_hu88ab44a91028cdf0e1dfd19d4e76e8bc_1274780_480x0_resize_box_3.png 480w, /post/52/75_hu88ab44a91028cdf0e1dfd19d4e76e8bc_1274780_1024x0_resize_box_3.png 1024w" width=1377 height=782 loading=lazy></a></figure></p><p>老生常谈的崖壁渲染，上面标记成红色的就是崖壁。通常地形的相关纹理都是从俯视角拍的，UV 坐标对应的都是 World Position 的 (x, y)，而崖壁这种地貌在地形的纹理上对应的 Texel Resolution 就很小，这就会导致问题。</p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/76.png data-size=1377x785><img src=/post/52/76.png srcset="/post/52/76_huf997e513febb932f5d27d43326379761_1196538_480x0_resize_box_3.png 480w, /post/52/76_huf997e513febb932f5d27d43326379761_1196538_1024x0_resize_box_3.png 1024w" width=1377 height=785 loading=lazy></a></figure></p><p>去掉 Debug Draw 后的效果，看起来就很糟糕，拉伸得很严重。</p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/77.png data-size=1375x785><img src=/post/52/77.png srcset="/post/52/77_hu155826bc93989611fe765e3186be0dcf_1302726_480x0_resize_box_3.png 480w, /post/52/77_hu155826bc93989611fe765e3186be0dcf_1302726_1024x0_resize_box_3.png 1024w" width=1375 height=785 loading=lazy></a></figure></p><p>处理的办法是比较经典的 Tri-Planar Mapping，即使用世界坐标 xy、xz、yz 在三个投影方向上代替 UV 进行采样，然后再使用 Normal 对这三次采样结果进行混合。图中标记成红色和蓝色的崖壁是按照 x 轴、y 轴投影的结果。</p><p><figure style=flex-grow:175;flex-basis:421px><a href=/post/52/78.png data-size=1381x786><img src=/post/52/78.png srcset="/post/52/78_hub00b7fd2d0c0c7fa9b22aa2442167f62_147699_480x0_resize_box_3.png 480w, /post/52/78_hub00b7fd2d0c0c7fa9b22aa2442167f62_147699_1024x0_resize_box_3.png 1024w" width=1381 height=786 loading=lazy></a></figure></p><p>这会导致采样数变成原来的三倍，这种做法是比较 Expensive 的。</p><p><figure style=flex-grow:175;flex-basis:421px><a href=/post/52/79.png data-size=1379x786><img src=/post/52/79.png srcset="/post/52/79_hu0746c90892ae23b1d972188c64f2ef16_1295749_480x0_resize_box_3.png 480w, /post/52/79_hu0746c90892ae23b1d972188c64f2ef16_1295749_1024x0_resize_box_3.png 1024w" width=1379 height=786 loading=lazy></a></figure></p><p>另外一个问题就是崖壁通常离玩家比较远，一旦离远了，纹理的 Tiling 就会变得很明显，看起来重复度会很高。</p><p><figure style=flex-grow:174;flex-basis:419px><a href=/post/52/80.png data-size=1384x792><img src=/post/52/80.png srcset="/post/52/80_hu105c6ac29797482f3c27226019cbf77c_1211732_480x0_resize_box_3.png 480w, /post/52/80_hu105c6ac29797482f3c27226019cbf77c_1211732_1024x0_resize_box_3.png 1024w" width=1384 height=792 loading=lazy></a></figure></p><p>去掉 DebugDraw 之后的效果，还是比较明显的。</p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/81.png data-size=1382x788><img src=/post/52/81.png srcset="/post/52/81_hucb1e0bfc5d3f8ff6fd27b959df8e6baa_1286626_480x0_resize_box_3.png 480w, /post/52/81_hucb1e0bfc5d3f8ff6fd27b959df8e6baa_1286626_1024x0_resize_box_3.png 1024w" width=1382 height=788 loading=lazy></a></figure></p><p>做法是调整 UV Space 使其在 Screen Space 中分配更均匀，后面说了实际上是依靠离相机的距离对 Tiling 进行调整。</p><p><figure style=flex-grow:175;flex-basis:421px><a href=/post/52/82.png data-size=1379x786><img src=/post/52/82.png srcset="/post/52/82_huae5888425d147a9aded49874c1e9164d_1215380_480x0_resize_box_3.png 480w, /post/52/82_huae5888425d147a9aded49874c1e9164d_1215380_1024x0_resize_box_3.png 1024w" width=1379 height=786 loading=lazy></a></figure></p><p>调整之后的效果。</p><p><figure style=flex-grow:176;flex-basis:423px><a href=/post/52/83.png data-size=1388x787><img src=/post/52/83.png srcset="/post/52/83_huc0f56c060c7aa6f5e600398879e42bdc_171427_480x0_resize_box_3.png 480w, /post/52/83_huc0f56c060c7aa6f5e600398879e42bdc_171427_1024x0_resize_box_3.png 1024w" width=1388 height=787 loading=lazy></a></figure></p><p>因为依赖距离进行调整，要对材质做一次 Blend，又导致采样翻倍了。</p><p><figure style=flex-grow:175;flex-basis:421px><a href=/post/52/84.png data-size=1370x780><img src=/post/52/84.png srcset="/post/52/84_hu4928bd62ef0848526f4cf3e9edfb1cc4_232133_480x0_resize_box_3.png 480w, /post/52/84_hu4928bd62ef0848526f4cf3e9edfb1cc4_232133_1024x0_resize_box_3.png 1024w" width=1370 height=780 loading=lazy></a></figure></p><p>一些 Cheaper 的崖壁替代方案以及问题。</p><p><figure style=flex-grow:177;flex-basis:424px><a href=/post/52/85.png data-size=1381x780><img src=/post/52/85.png srcset="/post/52/85_hu01d4ea80339e099fc94a38dc2e43c94b_324500_480x0_resize_box_3.png 480w, /post/52/85_hu01d4ea80339e099fc94a38dc2e43c94b_324500_1024x0_resize_box_3.png 1024w" width=1381 height=780 loading=lazy></a></figure></p><p>团队想到一种 Crazy 的方案，使用随机 Blending 替代 Alpha Blending，从像素级别上看，随机 Blending 效果是不对的，但是平均来看，是大致正确的。</p><p><figure style=flex-grow:176;flex-basis:422px><a href=/post/52/86.png data-size=1380x784><img src=/post/52/86.png srcset="/post/52/86_hu5dc9d4b8968bab1ba4c11fde34b44ea4_185556_480x0_resize_box_3.png 480w, /post/52/86_hu5dc9d4b8968bab1ba4c11fde34b44ea4_185556_1024x0_resize_box_3.png 1024w" width=1380 height=784 loading=lazy></a></figure></p><p>于是崖壁的 Shading 就不再每个像素都采多次 Splat Map 了，而是每个像素随机选择，然后只采一次 Splat Map，采样数直接降低到 4，但是效果不太行。</p><p><figure style=flex-grow:174;flex-basis:419px><a href=/post/52/87.png data-size=1420x812><img src=/post/52/87.png srcset="/post/52/87_hu49b4d743d2c331dceca4b7262a105348_83775_480x0_resize_box_3.png 480w, /post/52/87_hu49b4d743d2c331dceca4b7262a105348_83775_1024x0_resize_box_3.png 1024w" width=1420 height=812 loading=lazy></a></figure></p><p>Noise Function 的选择会直接决定质量，无论是 Screen Space 还是 World Space 的 Noise Function，都有优劣。</p><p><figure style=flex-grow:176;flex-basis:423px><a href=/post/52/88.png data-size=1420x804><img src=/post/52/88.png srcset="/post/52/88_hu59bbd78cd9941fe76ce322b5466d993d_459484_480x0_resize_box_3.png 480w, /post/52/88_hu59bbd78cd9941fe76ce322b5466d993d_459484_1024x0_resize_box_3.png 1024w" width=1420 height=804 loading=lazy></a></figure></p><p>最终选了 NVIDIA 的一篇论文中的算法。</p><p><figure style=flex-grow:176;flex-basis:423px><a href=/post/52/89.png data-size=1418x803><img src=/post/52/89.png srcset="/post/52/89_hua225f0a82f88e149eb2dc603d7dc81d0_104418_480x0_resize_box_3.png 480w, /post/52/89_hua225f0a82f88e149eb2dc603d7dc81d0_104418_1024x0_resize_box_3.png 1024w" width=1418 height=803 loading=lazy></a></figure></p><p>但是不幸的是噪点还是太多了，于是团队开始尝试将随机 Blending 和 Alpha Blending 结合起来。</p><p><figure style=flex-grow:174;flex-basis:419px><a href=/post/52/90.png data-size=1416x810><img src=/post/52/90.png srcset="/post/52/90_hua9213763727723b9bfc6a8c8c8b2335e_198063_480x0_resize_box_3.png 480w, /post/52/90_hua9213763727723b9bfc6a8c8c8b2335e_198063_1024x0_resize_box_3.png 1024w" width=1416 height=810 loading=lazy></a></figure></p><p>对于远处的崖壁，有前面说的 Tiling 的问题，所以就按之前说的，在两个材质中各随机一次，然后再做 Alpha Blending，这样采样数就变成了 8。</p><p><figure style=flex-grow:177;flex-basis:425px><a href=/post/52/91.png data-size=1423x802><img src=/post/52/91.png srcset="/post/52/91_hu81091b6bf7077fa6fccaa0e72f36397d_1407163_480x0_resize_box_3.png 480w, /post/52/91_hu81091b6bf7077fa6fccaa0e72f36397d_1407163_1024x0_resize_box_3.png 1024w" width=1423 height=802 loading=lazy></a></figure></p><p>DebugDraw 下看，其实还是有噪点的。</p><p><figure style=flex-grow:176;flex-basis:422px><a href=/post/52/92.png data-size=1418x805><img src=/post/52/92.png srcset="/post/52/92_hu1626b09a830f248745acf02f43058e28_1304458_480x0_resize_box_3.png 480w, /post/52/92_hu1626b09a830f248745acf02f43058e28_1304458_1024x0_resize_box_3.png 1024w" width=1418 height=805 loading=lazy></a></figure></p><p>但是关了 DebugDraw 之后，感觉可以接受。</p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/93.png data-size=1417x809><img src=/post/52/93.png srcset="/post/52/93_huec503aeb654b63d812d796faa38658bc_199237_480x0_resize_box_3.png 480w, /post/52/93_huec503aeb654b63d812d796faa38658bc_199237_1024x0_resize_box_3.png 1024w" width=1417 height=809 loading=lazy></a></figure></p><p>考虑到崖壁接近相机的情况，在这个距离下，其实不需要下面的材质混合，但是随机选一个方向作为最后的结果效果不太行，所以还是做了完整的 Tri-Planar 混合。</p><p><figure style=flex-grow:176;flex-basis:423px><a href=/post/52/94.png data-size=1412x801><img src=/post/52/94.png srcset="/post/52/94_hue894729d6066e38353fafbe158c3aaa2_107111_480x0_resize_box_3.png 480w, /post/52/94_hue894729d6066e38353fafbe158c3aaa2_107111_1024x0_resize_box_3.png 1024w" width=1412 height=801 loading=lazy></a></figure></p><p>这里采样数应该写反了，应该是近处 12，远处 8。</p><p><figure style=flex-grow:177;flex-basis:425px><a href=/post/52/95.png data-size=1419x801><img src=/post/52/95.png srcset="/post/52/95_hu717ed5b0f525c23a4060edb15edd0ab2_1203209_480x0_resize_box_3.png 480w, /post/52/95_hu717ed5b0f525c23a4060edb15edd0ab2_1203209_1024x0_resize_box_3.png 1024w" width=1419 height=801 loading=lazy></a></figure></p><p>实测下来没发现太大的问题，但是依然不完美。这种随机 Blending 中的任何噪点带来的变化实际上都是材质的变化（Splat Map 采的是 Material Id），拉近了看实际上是能看见材质的细微变化的。</p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/96.png data-size=1417x808><img src=/post/52/96.png srcset="/post/52/96_hu76f9f4036a7d5855029503af5be9a982_1897554_480x0_resize_box_3.png 480w, /post/52/96_hu76f9f4036a7d5855029503af5be9a982_1897554_1024x0_resize_box_3.png 1024w" width=1417 height=808 loading=lazy></a></figure></p><p>地形之外的一些东西，主要是贴花和地形相关的 Mesh。</p><p><figure style=flex-grow:176;flex-basis:424px><a href=/post/52/97.png data-size=1416x801><img src=/post/52/97.png srcset="/post/52/97_hu024bba6b57151b9b2848f6df636be277_713770_480x0_resize_box_3.png 480w, /post/52/97_hu024bba6b57151b9b2848f6df636be277_713770_1024x0_resize_box_3.png 1024w" width=1416 height=801 loading=lazy></a></figure></p><p>Far Cry 5 的贴花系统是基于 VT 的，团队改进了这套贴花系统，并称其 Terrain Displacement Decals。就是在传统 VT 贴花的基础上，加了贴花对地形 Mesh 的影响。</p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/98.png data-size=1419x809><img src=/post/52/98.png srcset="/post/52/98_hud8555f66f25260aed784b5992f7b1aad_1576311_480x0_resize_box_3.png 480w, /post/52/98_hud8555f66f25260aed784b5992f7b1aad_1576311_1024x0_resize_box_3.png 1024w" width=1419 height=809 loading=lazy></a></figure></p><p>放置贴花的时候，贴花 Mesh 会附着在地形上，Pixel Shader 阶段直接采地形的 VT 就可以了，因为贴花的纹理已经被画在 VT 上了。</p><p><figure style=flex-grow:175;flex-basis:421px><a href=/post/52/99.png data-size=1416x807><img src=/post/52/99.png srcset="/post/52/99_hu64af17b22abd26662097a9df48f9118d_1369187_480x0_resize_box_3.png 480w, /post/52/99_hu64af17b22abd26662097a9df48f9118d_1369187_1024x0_resize_box_3.png 1024w" width=1416 height=807 loading=lazy></a></figure></p><p><figure style=flex-grow:175;flex-basis:422px><a href=/post/52/100.png data-size=1411x802><img src=/post/52/100.png srcset="/post/52/100_huca8d66dc486be078655ff7367e5a9f22_1368579_480x0_resize_box_3.png 480w, /post/52/100_huca8d66dc486be078655ff7367e5a9f22_1368579_1024x0_resize_box_3.png 1024w" width=1411 height=802 loading=lazy></a></figure></p><p>Displacement Mesh 还没开的时候，其实就能看见传统 VT 贴花的效果了，只是开了之后贴花物体的形状会更加清晰（好像看不出来 &mldr;&mldr;）。</p><p><figure style=flex-grow:176;flex-basis:423px><a href=/post/52/101.png data-size=1418x804><img src=/post/52/101.png srcset="/post/52/101_hu89afc45a216c522e4550354b63f42193_140255_480x0_resize_box_3.png 480w, /post/52/101_hu89afc45a216c522e4550354b63f42193_140255_1024x0_resize_box_3.png 1024w" width=1418 height=804 loading=lazy></a></figure></p><p>优缺点，主要缺点是由于不是 Tessellation，所以需要人摆，当然也可以程序化生成。</p><p><figure style=flex-grow:176;flex-basis:422px><a href=/post/52/102.png data-size=1422x807><img src=/post/52/102.png srcset="/post/52/102_hu953b2e347974e06a5004ab125f8497f5_1224110_480x0_resize_box_3.png 480w, /post/52/102_hu953b2e347974e06a5004ab125f8497f5_1224110_1024x0_resize_box_3.png 1024w" width=1422 height=807 loading=lazy></a></figure></p><p><figure style=flex-grow:175;flex-basis:421px><a href=/post/52/103.png data-size=1417x807><img src=/post/52/103.png srcset="/post/52/103_hu3ad3f84eb14a20d849cb5835dec8b26c_1227220_480x0_resize_box_3.png 480w, /post/52/103_hu3ad3f84eb14a20d849cb5835dec8b26c_1227220_1024x0_resize_box_3.png 1024w" width=1417 height=807 loading=lazy></a></figure></p><p>崖壁会走程序化生成管线生成 Mesh，看起来会比高度图渲染的崖壁更真实。</p><p><figure style=flex-grow:175;flex-basis:421px><a href=/post/52/104.png data-size=1416x806><img src=/post/52/104.png srcset="/post/52/104_hu8e4a7c419c0ed2e51f9859c9a9378e0b_1243854_480x0_resize_box_3.png 480w, /post/52/104_hu8e4a7c419c0ed2e51f9859c9a9378e0b_1243854_1024x0_resize_box_3.png 1024w" width=1416 height=806 loading=lazy></a></figure></p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/105.png data-size=1416x808><img src=/post/52/105.png srcset="/post/52/105_hu88de05aab289522fad60748238c70571_1234413_480x0_resize_box_3.png 480w, /post/52/105_hu88de05aab289522fad60748238c70571_1234413_1024x0_resize_box_3.png 1024w" width=1416 height=808 loading=lazy></a></figure></p><p>另一个例子。</p><p><figure style=flex-grow:175;flex-basis:422px><a href=/post/52/106.png data-size=1419x807><img src=/post/52/106.png srcset="/post/52/106_hu35efdc3fc97449e4bcb8056a0daba9ea_1900711_480x0_resize_box_3.png 480w, /post/52/106_hu35efdc3fc97449e4bcb8056a0daba9ea_1900711_1024x0_resize_box_3.png 1024w" width=1419 height=807 loading=lazy></a></figure></p><p>屏幕空间 Shading。</p><p><figure style=flex-grow:176;flex-basis:422px><a href=/post/52/107.png data-size=1424x808><img src=/post/52/107.png srcset="/post/52/107_hudf5341f9245ba5ea3ef05f5e28d838ec_969441_480x0_resize_box_3.png 480w, /post/52/107_hudf5341f9245ba5ea3ef05f5e28d838ec_969441_1024x0_resize_box_3.png 1024w" width=1424 height=808 loading=lazy></a></figure></p><p>整个屏幕空间通常能看见的东西有这么几种，每一种都是不同的 Shading Flavors。因为彼此需要混合，最终有 31 种 Shader 变体。有一些 Shader 变体的开销会比其他的 Expensive 很多，为了保持 GPU 效率，需要保证对每一块地形都使用 Cheapest 的 Shader 变体。</p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/108.png data-size=1417x808><img src=/post/52/108.png srcset="/post/52/108_hu5b7bbcc201a77317a99e533a9c4a7215_764898_480x0_resize_box_3.png 480w, /post/52/108_hu5b7bbcc201a77317a99e533a9c4a7215_764898_1024x0_resize_box_3.png 1024w" width=1417 height=808 loading=lazy></a></figure></p><p>最简单的方法就是根据 Patch 选择 Shader ID，但是这种做法并不一定最优因为 Patch 的范围其实还挺大的。</p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/109.png data-size=1417x808><img src=/post/52/109.png srcset="/post/52/109_hu8b1ed06066d05b8d6308588001de7e7c_787535_480x0_resize_box_3.png 480w, /post/52/109_hu8b1ed06066d05b8d6308588001de7e7c_787535_1024x0_resize_box_3.png 1024w" width=1417 height=808 loading=lazy></a></figure></p><p>最终决定按屏幕空间的 Tile 来进行 Shader ID 的选择。</p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/110.png data-size=1418x809><img src=/post/52/110.png srcset="/post/52/110_hu36ac3b7f681496c401d8cc007bdfc5ca_617309_480x0_resize_box_3.png 480w, /post/52/110_hu36ac3b7f681496c401d8cc007bdfc5ca_617309_1024x0_resize_box_3.png 1024w" width=1418 height=809 loading=lazy></a></figure></p><p>在 Geometry Pass 中使用 MRT 输出一张 8Bit 的 Classification RT，其中保存了 5 种 Shading Flavors 的 Bitmask。</p><p><figure style=flex-grow:176;flex-basis:423px><a href=/post/52/111.png data-size=1422x806><img src=/post/52/111.png srcset="/post/52/111_hua638fe13053ce67c94cab11faec94a60_545302_480x0_resize_box_3.png 480w, /post/52/111_hua638fe13053ce67c94cab11faec94a60_545302_1024x0_resize_box_3.png 1024w" width=1422 height=806 loading=lazy></a></figure></p><p>接下来是一个 Full Screen 的 Compute Pass 被称为 Terrain Classification Pass，读取前面的 Classification RT，按照 8x8 的 Tile 来合并具有相同 Shader Id 的 Tile，并输出 Indirect Args 给下一步使用。</p><p><figure style=flex-grow:176;flex-basis:423px><a href=/post/52/112.png data-size=1421x806><img src=/post/52/112.png srcset="/post/52/112_hu97160c6a69ed19e86693ade6f5a14279_576792_480x0_resize_box_3.png 480w, /post/52/112_hu97160c6a69ed19e86693ade6f5a14279_576792_1024x0_resize_box_3.png 1024w" width=1421 height=806 loading=lazy></a></figure></p><p>然后就是渲染 G-Buffer。</p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/113.png data-size=1416x809><img src=/post/52/113.png srcset="/post/52/113_hu76f767c476559922f0c7815f25b019e3_730393_480x0_resize_box_3.png 480w, /post/52/113_hu76f767c476559922f0c7815f25b019e3_730393_1024x0_resize_box_3.png 1024w" width=1416 height=809 loading=lazy></a></figure></p><p>整套流程的 Overview。</p><p><figure style=flex-grow:176;flex-basis:423px><a href=/post/52/114.png data-size=1432x812><img src=/post/52/114.png srcset="/post/52/114_hu44ef4ef05737b274719ce30e39d49cde_246674_480x0_resize_box_3.png 480w, /post/52/114_hu44ef4ef05737b274719ce30e39d49cde_246674_1024x0_resize_box_3.png 1024w" width=1432 height=812 loading=lazy></a></figure></p><p>采样 Terrain 纹理的过程是先从深度 Buffer 中取出 World Position，然后通过 Terrain Sector Data 来获取具体的纹理信息。</p><p><figure style=flex-grow:177;flex-basis:425px><a href=/post/52/115.png data-size=1419x801><img src=/post/52/115.png srcset="/post/52/115_hua1e0e93e9a543ea1602d335007ceefbc_669699_480x0_resize_box_3.png 480w, /post/52/115_hua1e0e93e9a543ea1602d335007ceefbc_669699_1024x0_resize_box_3.png 1024w" width=1419 height=801 loading=lazy></a></figure></p><p>Terrain Sector Data 是一个 160x160 的 64Bits 的 Buffer，对应 160x160 Sectors，每一个单元保存了这个 Sector 需要的 Atlas Texture Ids，拿 World Position 在 Buffer 里找就能拿到对应信息。</p><p><figure style=flex-grow:176;flex-basis:422px><a href=/post/52/116.png data-size=1417x804><img src=/post/52/116.png srcset="/post/52/116_hu03fc22ebe69c99e619c40d85e1402a22_171442_480x0_resize_box_3.png 480w, /post/52/116_hu03fc22ebe69c99e619c40d85e1402a22_171442_1024x0_resize_box_3.png 1024w" width=1417 height=804 loading=lazy></a></figure></p><p>在 Shading Pass 需要用到 Texture 导数（类似 ddx、ddy？只不过是 Texture 空间的）。因为地形相关的纹理的 UV 其实都是 World Space Position 的线性映射，所以只要求出 World Space Position 的导数，就可以求出 Texture 导数。</p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/117.png data-size=1419x809><img src=/post/52/117.png srcset="/post/52/117_hu1325da21feedc0c48578f950c440481c_1145856_480x0_resize_box_3.png 480w, /post/52/117_hu1325da21feedc0c48578f950c440481c_1145856_1024x0_resize_box_3.png 1024w" width=1419 height=809 loading=lazy></a></figure></p><p>对于屏幕空间的像素（x, y），先从深度获取 World Space Position，然后拿到 World Space Normal，用拿到的 Normal 构建一个平面，拿着相机到像素（x, y+1）的射线与平面求交，交点就是屏幕空间 World Space Position 在 y 方向上的导数，同理，拿 （x+1, y）来求 x 方向上的导数。</p><p><figure style=flex-grow:174;flex-basis:419px><a href=/post/52/118.png data-size=1416x810><img src=/post/52/118.png srcset="/post/52/118_huc0f8faa3da5d90b7fa4ae3b42e774db8_280690_480x0_resize_box_3.png 480w, /post/52/118_huc0f8faa3da5d90b7fa4ae3b42e774db8_280690_1024x0_resize_box_3.png 1024w" width=1416 height=810 loading=lazy></a></figure></p><p>刚刚说过崖壁等会替换成特定的 Mesh，这种情况下就不再适用了。</p><p><figure style=flex-grow:175;flex-basis:421px><a href=/post/52/119.png data-size=1428x813><img src=/post/52/119.png srcset="/post/52/119_huc43540957259f6a7039fc17b703f5aee_142328_480x0_resize_box_3.png 480w, /post/52/119_huc43540957259f6a7039fc17b703f5aee_142328_1024x0_resize_box_3.png 1024w" width=1428 height=813 loading=lazy></a></figure></p><p>解决方法是在 Terrain Geometry Pass 中用 MRT 输出一张 Normal 纹理。</p><p><figure style=flex-grow:174;flex-basis:419px><a href=/post/52/120.png data-size=1418x812><img src=/post/52/120.png srcset="/post/52/120_hu90ee668ecf397812629b72f3927a1f76_285465_480x0_resize_box_3.png 480w, /post/52/120_hu90ee668ecf397812629b72f3927a1f76_285465_1024x0_resize_box_3.png 1024w" width=1418 height=812 loading=lazy></a></figure></p><p>然鹅 Normal 会被插值，插值之后可能就不对了。</p><p><figure style=flex-grow:174;flex-basis:419px><a href=/post/52/121.png data-size=1420x812><img src=/post/52/121.png srcset="/post/52/121_hu7bc40beba9e72f9ebf3431f6313ae582_130148_480x0_resize_box_3.png 480w, /post/52/121_hu7bc40beba9e72f9ebf3431f6313ae582_130148_1024x0_resize_box_3.png 1024w" width=1420 height=812 loading=lazy></a></figure></p><p>解决方法是把三角形的 Normal 也输出到 RT 里，然后把两个 Normal 编码到 32Bit 里，每个 Normal 16 Bits。</p><p><figure style=flex-grow:175;flex-basis:422px><a href=/post/52/122.png data-size=1421x808><img src=/post/52/122.png srcset="/post/52/122_hu675028ca191ce99ba439633ef6aa3ed8_803947_480x0_resize_box_3.png 480w, /post/52/122_hu675028ca191ce99ba439633ef6aa3ed8_803947_1024x0_resize_box_3.png 1024w" width=1421 height=808 loading=lazy></a></figure></p><p>最终流程。</p><p><figure style=flex-grow:176;flex-basis:424px><a href=/post/52/123.png data-size=1424x806><img src=/post/52/123.png srcset="/post/52/123_huea0b97af2d514deb4de512b1b9748b78_172360_480x0_resize_box_3.png 480w, /post/52/123_huea0b97af2d514deb4de512b1b9748b78_172360_1024x0_resize_box_3.png 1024w" width=1424 height=806 loading=lazy></a></figure></p><p>优缺点。</p><p><figure style=flex-grow:176;flex-basis:423px><a href=/post/52/124.png data-size=1421x806><img src=/post/52/124.png srcset="/post/52/124_hu5a295d20bd5cf5465fb44f4a966c72e4_125950_480x0_resize_box_3.png 480w, /post/52/124_hu5a295d20bd5cf5465fb44f4a966c72e4_125950_1024x0_resize_box_3.png 1024w" width=1421 height=806 loading=lazy></a></figure></p><p>性能。</p><p><figure style=flex-grow:174;flex-basis:419px><a href=/post/52/125.png data-size=1416x810><img src=/post/52/125.png srcset="/post/52/125_hue181835b84987534c5d87a3de2aa5903_1892914_480x0_resize_box_3.png 480w, /post/52/125_hue181835b84987534c5d87a3de2aa5903_1892914_1024x0_resize_box_3.png 1024w" width=1416 height=810 loading=lazy></a></figure></p><p>一些基于地形的效果。</p><p><figure style=flex-grow:174;flex-basis:419px><a href=/post/52/126.png data-size=1412x807><img src=/post/52/126.png srcset="/post/52/126_hu82f81717fc4dde74bfb102314013c00b_651637_480x0_resize_box_3.png 480w, /post/52/126_hu82f81717fc4dde74bfb102314013c00b_651637_1024x0_resize_box_3.png 1024w" width=1412 height=807 loading=lazy></a></figure></p><p>回顾下前面的 Terrain Scetor Data，只要有 World Position，就可以拿到地形上任意一个点对应的纹理信息（Height、Albedo、Normal、Splat 等）。</p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/127.png data-size=1417x808><img src=/post/52/127.png srcset="/post/52/127_huf5d4c2f9621e64af7a3ed73851ca1de9_1427696_480x0_resize_box_3.png 480w, /post/52/127_huf5d4c2f9621e64af7a3ed73851ca1de9_1427696_1024x0_resize_box_3.png 1024w" width=1417 height=808 loading=lazy></a></figure></p><p><figure style=flex-grow:175;flex-basis:420px><a href=/post/52/128.png data-size=1416x808><img src=/post/52/128.png srcset="/post/52/128_hu83c365fb49fcd308a7f12b4ce99561b7_1432873_480x0_resize_box_3.png 480w, /post/52/128_hu83c365fb49fcd308a7f12b4ce99561b7_1432873_1024x0_resize_box_3.png 1024w" width=1416 height=808 loading=lazy></a></figure></p><p>其中一个作用就是在树根的 Shading 里，可以在 Vertex Shader 中采样地形的高度图来做与地表的混合。</p><p><figure style=flex-grow:175;flex-basis:421px><a href=/post/52/129.png data-size=1418x807><img src=/post/52/129.png srcset="/post/52/129_hu3c037ce57e230772c4b73b2cf5e5768c_1407284_480x0_resize_box_3.png 480w, /post/52/129_hu3c037ce57e230772c4b73b2cf5e5768c_1407284_1024x0_resize_box_3.png 1024w" width=1418 height=807 loading=lazy></a></figure></p><p><figure style=flex-grow:174;flex-basis:419px><a href=/post/52/130.png data-size=1413x808><img src=/post/52/130.png srcset="/post/52/130_hu0a95aaece3d0b960c0d8987d68ad9945_1362304_480x0_resize_box_3.png 480w, /post/52/130_hu0a95aaece3d0b960c0d8987d68ad9945_1362304_1024x0_resize_box_3.png 1024w" width=1413 height=808 loading=lazy></a></figure></p><p>碎石也用了类似的处理。</p><p><figure style=flex-grow:176;flex-basis:424px><a href=/post/52/131.png data-size=1417x802><img src=/post/52/131.png srcset="/post/52/131_hu49055cfdd48e0651e1901e5703048287_1283177_480x0_resize_box_3.png 480w, /post/52/131_hu49055cfdd48e0651e1901e5703048287_1283177_1024x0_resize_box_3.png 1024w" width=1417 height=802 loading=lazy></a></figure></p><p>最后一级 LOD 的草也用了地形高度图，比较近的草需要比较高的渲染精度，但是离远了就直接换成与地形高度、颜色匹配的 Quads。</p><p><figure style=flex-grow:176;flex-basis:423px><a href=/post/52/132.png data-size=1415x802><img src=/post/52/132.png srcset="/post/52/132_hudb59dce2c4f29bf0b3d5c947865a7ea0_1314107_480x0_resize_box_3.png 480w, /post/52/132_hudb59dce2c4f29bf0b3d5c947865a7ea0_1314107_1024x0_resize_box_3.png 1024w" width=1415 height=802 loading=lazy></a></figure></p><p><figure style=flex-grow:175;flex-basis:422px><a href=/post/52/133.png data-size=1413x803><img src=/post/52/133.png srcset="/post/52/133_hu3a1568bc421860d0bbb04f20e606a63b_1317341_480x0_resize_box_3.png 480w, /post/52/133_hu3a1568bc421860d0bbb04f20e606a63b_1317341_1024x0_resize_box_3.png 1024w" width=1413 height=803 loading=lazy></a></figure></p><p>这些草的生成是使用 Compute Shader 在每一帧去采样地形材质的类型、Height、Color、Normal 等，然后生成 Indirect Args，最后一次 Indirect Draw 完成绘制，可以看到开关后的对比。</p><p><figure style=flex-grow:176;flex-basis:422px><a href=/post/52/134.png data-size=1415x803><img src=/post/52/134.png srcset="/post/52/134_hu50c2cc0af2efc52474bb0a746aa87540_1855876_480x0_resize_box_3.png 480w, /post/52/134_hu50c2cc0af2efc52474bb0a746aa87540_1855876_1024x0_resize_box_3.png 1024w" width=1415 height=803 loading=lazy></a></figure></p><p><figure style=flex-grow:175;flex-basis:421px><a href=/post/52/135.png data-size=1416x806><img src=/post/52/135.png srcset="/post/52/135_hu9f8e30a5fe7a1326e4c069a4038d899d_284099_480x0_resize_box_3.png 480w, /post/52/135_hu9f8e30a5fe7a1326e4c069a4038d899d_284099_1024x0_resize_box_3.png 1024w" width=1416 height=806 loading=lazy></a></figure></p><p>总结。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/gdc/>GDC</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>相关文章</h2><div class=related-contents><div class="flex article-list--tile"><article><a href=/post/57/><div class=article-details><h2 class=article-title>GDC 笔记 - Simulating Tropical Weather in FARCRY6</h2></div></a></article><article><a href=/post/56/><div class=article-details><h2 class=article-title>GDC 笔记 - FidelityFX Super Resolution 2.0</h2></div></a></article><article><a href=/post/53/><div class=article-details><h2 class=article-title>GDC 笔记 - Quadtree Displacement Mapping with Height Blending</h2></div></a></article><article><a href=/post/51/><div class=article-details><h2 class=article-title>GDC 笔记 - 'Ghost Recon Wildlands': Terrain Tools and Technology</h2></div></a></article><article><a href=/post/58/><div class=article-details><h2 class=article-title>如何以酷炫的姿势造一个 C++ 动态反射轮子</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=FlyAndNotDown/KindemBlog issue-term=title crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;setUtterancesTheme(document.body.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2017 -
2023 Kindem的博客</section><section class=powerby>©2017-2021 Copyright kindem.xyz / 湘ICP备17018771号-1<br>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=2.3.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>