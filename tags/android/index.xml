<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Android on Kindem的博客</title><link>https://www.kindem.xyz/tags/android/</link><description>Recent content in Android on Kindem的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 03 Jan 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://www.kindem.xyz/tags/android/index.xml" rel="self" type="application/rss+xml"/><item><title>浅谈 Android 插件化原理</title><link>https://www.kindem.xyz/post/29/</link><pubDate>Sun, 03 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.kindem.xyz/post/29/</guid><description>🔌 认识插件化 想必大家都知道，在 Android 系统中，应用是以 Apk 的形式存在的，应用都需要安装才能使用。但实际上 Android 系统安装应用的方式相当简单，其实就是把应用 Apk 拷贝到系统不同的目录下、然后把 so 解压出来而已。
常见的应用安装目录有：
/system/app：系统应用 /system/priv-app：系统应用 /data/app：用户应用 那可能大家会想问，既然安装这个过程如此简单，Android 是怎么运行应用中的代码的呢，我们先看 Apk 的构成，一个常见的 Apk 会包含如下几个部分：
classes.dex：Java 代码字节码 res：资源目录 lib：so 目录 assets：静态资产目录 AndroidManifest.xml：清单文件 其实 Android 系统在打开应用之后，也只是开辟进程，然后使用 ClassLoader 加载 classes.dex 至进程中，执行对应的组件而已。
那大家可能会想一个问题，既然 Android 本身也是使用类似反射的形式加载代码执行，凭什么我们不能执行一个 Apk 中的代码呢？
这其实就是插件化的目的，让 Apk 中的代码（主要是指 Android 组件）能够免安装运行，这样能够带来很多收益，最显而易见的优势其实就是通过网络热更新、热修复，想象一下，你的应用拥有 Native 应用一般极高的性能，又能获取诸如 Web 应用一样的收益。
嗯，理想很美好不是嘛？
🎯 难点在哪 大家其实都知道，Android 应用本身是基于魔改的 Java 虚拟机的，动态加载代码简直不要太简单，只需要使用 DexClassLoader 加载 Apk，然后反射里面的代码就可以了。
但是光能反射代码是没有意义的，插件化真正的魅力在于，可以动态加载执行 Android 组件（即 Activity、Service、BroadcastReceiver、ContentProvider、Fragment）等。
仔细想一下，其实要做到这一点是有难度的，最主要的阻碍是，四大组件是在系统里面中注册的，具体来说是在 Android 系统的 ActivityManagerService (AMS) 和 PackageManagerService (PMS) 中注册的，而四大组件的解析和启动都需要依赖 AMS 和 PMS，如何欺骗系统，让他承认一个未安装的 Apk 中的组件，就是插件化的最大难点。</description></item><item><title>Android 调试技巧总结</title><link>https://www.kindem.xyz/post/21/</link><pubDate>Mon, 30 Dec 2019 00:00:00 +0000</pubDate><guid>https://www.kindem.xyz/post/21/</guid><description>在 Android Studio 中，最基本的以 debug 模式运行程序并打断点进行调试，相比大家都会，不过，如果遇到一些特殊的调试场景，则需要运用一些特殊的调试技巧来进行调试。
🍗 在程序运行之后打断点调试 有时候，我们需要对已经运行的程序进行调试，这时候应该使用 Android Studio 的 Attach 功能：
Attach 点击工具栏中的 Attach Debugger to Android Process 按钮，会显示出可以 Attach 的进程：
如果未勾选 Show All Processes 选项，则只会显示当前项目对应的进程，勾选 Show All Processes 选项之后，则会显示当前机器上跑着的所有进程（需要 root 权限）。
在调试之前先打好断点，然后在这里选择目标进程之后，即可成功断上。
🍥 等待调试 在某些场景下，部分代码可能在程序一启动就执行完了，这种情况下，可以使用 “等待调试” 功能来让程序暂时停住，等待调试器 Attach 之后再开始执行。
第一种方法是直接在代码中添加：
import android.os.Debug; // ..... Debug.waitingForDebugger(); 编译运行后，当代码执行到这一句话之后，便会显示 Wait For Debugger 字样并且暂停执行，等待用户手动 Attach 之后才会接着执行，此时，就能断住之前执行太快断不住的代码进行调试了。
另外一种方法是使用 adb 指令：
adb shell am set-debug-app -w &amp;lt;packageName&amp;gt; 来设置待调试应用，设置了这一条语句之后启动对应应用之后则会停住，等待调试器 Attach，这种方法的好处是可以不用修改代码就让应用等待调试。
🧀 调试 Android SDK 源码 在一些特殊的场景，需要调试 Android SDK 源码中产生的异常，通过 Android SDK 源码中产生的现象发现自己写的代码逻辑的问题。</description></item><item><title>Android 蓝牙库 FastBLE 的使用方法</title><link>https://www.kindem.xyz/post/10/</link><pubDate>Fri, 25 May 2018 00:00:00 +0000</pubDate><guid>https://www.kindem.xyz/post/10/</guid><description>☕ FastBle VS 原生Android蓝牙API 原生 Android 的蓝牙 API 使用有点麻烦，要先获取设备的蓝牙适配器，接着注册广播来接受蓝牙设备信息，用完了还需要将广播给注销，相对来说有点麻烦。
不好封装，可以说是原生 Android 最让人痛苦的地方，这是因为原生 Android 的代码不是很独立，与 Activity、广播等相杂糅。市面上的蓝牙库也是少之又少，先看了看 BleLib，感觉还是换汤不换药，用起来一点也不简洁。
但是 FastLib 封装的就很技巧，基本上能把一个操作的粒度控制在一行内，另外，代码也无需与线程、通知之类的打交道，库中已经帮我们把这些复杂的东西都做完了。
FastBle 的 Github 项目地址在这，大家可以看看：FastBle - GitHub
它的文档也相对比较完整，大家可以查看官方文档来使用它：FastBle - Document
✨ FastBle的使用 0x00 申明权限 只要使用到了蓝牙，申明权限是必不可少的，FastBle 需要的权限如下:
&amp;lt;uses-permission android:name=&amp;#34;android.permission.BLUETOOTH&amp;#34; /&amp;gt; &amp;lt;uses-permission android:name=&amp;#34;android.permission.BLUETOOTH_ADMIN&amp;#34; /&amp;gt; &amp;lt;uses-permission android:name=&amp;#34;android.permission.ACCESS_COARSE_LOCATION&amp;#34; /&amp;gt; &amp;lt;uses-permission android:name=&amp;#34;android.permission.ACCESS_FINE_LOCATION&amp;#34; /&amp;gt; 这里要注意一点，如果 Android 版本高于 6.0，用户还需要打开位置信息(不光要位置权限，还需要打开位置信息)才能通过蓝牙进行扫描。
0x01 初始化与全局配置 初始化需要在库中任何函数被调用前执行，由于库使用的是单例模式，只需要初始化一次，在哪里都能使用，建议在 onCreate 里执行初始化代码：
BleManager.getInstance().init(getApplication()); 全局配置可以紧跟初始化之后执行，当然如果不进行配置也没有任何关系，每一个选项都有默认值：
BleManager.getInstance() .enableLog(true) .setReConnectCount(1, 5000) .setSplitWriteNum(20) .setConnectOverTime(10000) .setOperateTimeout(5000); 每一项的详细信息你都能在官方文档中找到说明
0x02 打开蓝牙 使用 FastBle 中的 BleManager 类有很多种方式来打开蓝牙，这里推荐使用下面这种方式，这种方式会使线程被阻塞，如果用户不选择是否打开蓝牙，线程将会暂停执行：</description></item></channel></rss>