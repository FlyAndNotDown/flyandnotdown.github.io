<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ on Kindem的博客</title><link>https://flyandnotdown.github.io/tags/c++/</link><description>Recent content in C++ on Kindem的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 25 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://flyandnotdown.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>如何以酷炫的姿势造一个 C++ 动态反射轮子</title><link>https://flyandnotdown.github.io/post/58/</link><pubDate>Sat, 25 Nov 2023 00:00:00 +0000</pubDate><guid>https://flyandnotdown.github.io/post/58/</guid><description>背景 写游戏引擎当然绕不开反射，反射在编辑器开发、序列化这块有着举足轻重的作用。
简单扫了一遍市面上的动态反射库，rttr 感觉已经不更新了，实际上用 CMake 集成到项目里感觉也不太好用，meta 其实还不错，思路很好，用模板做类型注册，但是比较整蛊的是查类型信息的使用用的不是 std::string，而是一个 hash 值，其实就是编译期字符串 hash，不够灵活，另外还缺一套自动注册的流程。UE 的反射库也比较完善，主要基于地址注册，而且有自动注册流程，但是缺点就是太依赖 UObject 系统了，而且年代久远所以相当笨重，独立项目不可能去引用的。
于是我打算自己造一套轮子，整体框架参考 meta，类型注册使用模板，引入 libclang 来做头文件的自动分析与类型自动注册，另外也支持已注册类型的对象自动序列化。
我给这套反射框架取名叫 Mirror，镜子反射很6，简单粗暴没毛病，你可以在 Explosion/Mirror 和 Explosion/MirrorTool 找到所有的相关代码和测试用例，让我们开始吧。
TypeInfo 首先我们需要为我们的类型构筑一个基本信息，直接给一个结构体，描述某一个类型的基本信息，这个信息后面会在很多地方用到，比如判断类型是否相等啦，Any Cast 的校验啦、派生关系的校验啦之类的。
using TypeId = size_t; struct TypeInfo { std::string name; TypeId id; const bool isConst; const bool isLValueReference; const bool isRValueReference; const bool isPointer; const bool isClass; TypeId removePointerType; }; 其实就是类型名、id、然后一些基本的 type traits，和一个 removePointerType，这些信息基本已经足够了，如果还需要别的可以在此基础上添加定制。
接下来我们需要一个模板函数，支持对一个类型求 TypeInfo：
template &amp;lt;typename T&amp;gt; TypeInfo* GetTypeInfo() { static TypeInfo typeInfo = { typeid(T).</description></item><item><title>C++ 模板黑魔法 —— 编译期序列与 std::tuple 遍历</title><link>https://flyandnotdown.github.io/post/45/</link><pubDate>Fri, 06 Aug 2021 00:00:00 +0000</pubDate><guid>https://flyandnotdown.github.io/post/45/</guid><description>编译期序列 最近看到一个很有意思的模板写法：
template &amp;lt;size_t... S&amp;gt; struct IndexSequence {}; template &amp;lt;size_t N, size_t... S&amp;gt; struct IndexSequenceMaker : public IndexSequenceMaker&amp;lt;N - 1, N - 1, S...&amp;gt; {}; template &amp;lt;size_t... S&amp;gt; struct IndexSequenceMaker&amp;lt;0, S...&amp;gt; { using Type = IndexSequence&amp;lt;S...&amp;gt;; }; template &amp;lt;size_t N&amp;gt; using MakeIndexSequence = typename IndexSequenceMaker&amp;lt;N&amp;gt;::Type; 乍一看啥玩意儿，仔细看会发现它的作用是生成一个编译期序列，如：
// IndexSequence&amp;lt;0, 1, 2, 3, 4&amp;gt; MakeIndexSequence&amp;lt;5&amp;gt; 它的实现非常巧妙，我们以上面这个例子为切入点，按照它的思路去展开模板：
template &amp;lt;&amp;gt; struct IndexSequenceMaker&amp;lt;0, 0, 1, 2, 3, 4&amp;gt; { using Type = IndexSequence&amp;lt;0, 1, 2, 3, 4&amp;gt;; } template &amp;lt;&amp;gt; struct IndexSequenceMaker&amp;lt;1, 1, 2, 3, 4&amp;gt; : public IndexSequenceMaker&amp;lt;0, 0, 1, 2, 3, 4&amp;gt; {} template &amp;lt;&amp;gt; struct IndexSequenceMaker&amp;lt;2, 2, 3, 4&amp;gt; : public IndexSequenceMaker&amp;lt;1, 1, 2, 3, 4&amp;gt;; template &amp;lt;&amp;gt; struct IndexSequenceMaker&amp;lt;3, 3, 4&amp;gt; : public IndexSequenceMaker&amp;lt;2, 2, 3, 4&amp;gt;; template &amp;lt;&amp;gt; struct IndexSequenceMaker&amp;lt;4, 4&amp;gt; : public IndexSequenceMaker&amp;lt;3, 3, 4&amp;gt;; template &amp;lt;&amp;gt; struct IndexSequenceMaker&amp;lt;5&amp;gt; : public IndexSequenceMaker&amp;lt;4, 4&amp;gt; {} template &amp;lt;&amp;gt; using MakeIndexSequence&amp;lt;5&amp;gt; = typename IndexSequenceMaker&amp;lt;5&amp;gt;::Type; 秒懂了，利用继承关系来传递不断生成的序列可变参，最后以 N = 0 的特化来终止生成。</description></item></channel></rss>