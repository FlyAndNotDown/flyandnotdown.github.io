<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>STL on Kindem的博客</title><link>https://flyandnotdown.github.io/tags/stl/</link><description>Recent content in STL on Kindem的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 26 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://flyandnotdown.github.io/tags/stl/index.xml" rel="self" type="application/rss+xml"/><item><title>MSVC std::unique_ptr 源码解析</title><link>https://flyandnotdown.github.io/post/48/</link><pubDate>Sun, 26 Sep 2021 00:00:00 +0000</pubDate><guid>https://flyandnotdown.github.io/post/48/</guid><description>介绍 std::unique_ptr 是 c++ 11 添加的智能指针之一，是裸指针的封装，我们可以直接使用裸指针来构造 std::unique_ptr：
struct TestStruct { int a; int b; }; class TestClass { public: TestClass() = default; TestClass(int a, int b) : a(a), b(b) {} private: int a; int b; }; std::unique_ptr&amp;lt;int&amp;gt; p0 = std::unique_ptr&amp;lt;int&amp;gt;(new int { 1 }); std::unique_ptr&amp;lt;TestStruct&amp;gt; p1 = std::unique_ptr&amp;lt;TestStruct&amp;gt;(new TestStruct { 1, 2 }); std::unique_ptr&amp;lt;TestClass&amp;gt; p2 = std::unique_ptr&amp;lt;TestClass&amp;gt;(new TestClass(1, 2)); 在 c++ 14 及以上，可以使用 std::make_unique 来更方便地构造 std::unique_ptr，参数列表需匹配创建对象的构造函数：
std::unique_ptr&amp;lt;int&amp;gt; p0 = std::make_unique&amp;lt;int&amp;gt;(1); std::unique_ptr&amp;lt;TestStruct&amp;gt; p1 = std::make_unique&amp;lt;TestStruct&amp;gt;(TestStruct { 1, 2 }); std::unique_ptr&amp;lt;TestClass&amp;gt; p2 = std::make_unique&amp;lt;TestClass&amp;gt;(1, 2); 除了保存普通对象，std::unique_ptr 还能保存数组，这时 std::make_unique 的参数表示数组的长度：</description></item><item><title>MSVC std::any 源码解析</title><link>https://flyandnotdown.github.io/post/46/</link><pubDate>Sat, 28 Aug 2021 00:00:00 +0000</pubDate><guid>https://flyandnotdown.github.io/post/46/</guid><description>std::any 介绍 std::any 是 c++17 标准新提供的类，作用是存储任意类型的一段内存，并可以重复赋值，在赋值后可以使用 std::any_cast 将 std::any 所存储的值转换成特定类型，如果 std::any 中存储的值的类型与目标类型不匹配，则会抛出 std::bad_any_cast 异常。
下面是一些简单的 Sample Code（MSVC 16 2019 64Bit 运行）：
std::any value = 1.0; // 1 std::cout &amp;lt;&amp;lt; any_cast&amp;lt;double&amp;gt;(value) &amp;lt;&amp;lt; std::endl; // 抛出 std::bad_any_cast 异常 std::cout &amp;lt;&amp;lt; any_cast&amp;lt;float&amp;gt;(value) &amp;lt;&amp;lt; std::endl; // 抛出 std::bad_any_cast 异常 std::cout &amp;lt;&amp;lt; any_cast&amp;lt;int&amp;gt;(value) &amp;lt;&amp;lt; std::endl; 指针示例：
std::any value1 = nullptr; // nullptr std::cout &amp;lt;&amp;lt; any_cast&amp;lt;nullptr_t&amp;gt;(value1) &amp;lt;&amp;lt; std::endl; // 抛出 std::bad_any_cast 异常 std::cout &amp;lt;&amp;lt; any_cast&amp;lt;int*&amp;gt;(value1) &amp;lt;&amp;lt; std::endl; std::any value2 = (int*) (nullptr); // 抛出 std::bad_any_cast 异常 std::cout &amp;lt;&amp;lt; any_cast&amp;lt;nullptr_t&amp;gt;(value2) &amp;lt;&amp;lt; std::endl; // 0000000000000000 std::cout &amp;lt;&amp;lt; any_cast&amp;lt;int*&amp;gt;(value2) &amp;lt;&amp;lt; std::endl; 空 std::any 示例：</description></item></channel></rss>