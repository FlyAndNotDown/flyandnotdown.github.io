<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>FastBLE on Kindem的博客</title><link>https://flyandnotdown.github.io/tags/fastble/</link><description>Recent content in FastBLE on Kindem的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 25 May 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://flyandnotdown.github.io/tags/fastble/index.xml" rel="self" type="application/rss+xml"/><item><title>Android 蓝牙库 FastBLE 的使用方法</title><link>https://flyandnotdown.github.io/post/10/</link><pubDate>Fri, 25 May 2018 00:00:00 +0000</pubDate><guid>https://flyandnotdown.github.io/post/10/</guid><description>☕ FastBle VS 原生Android蓝牙API 原生 Android 的蓝牙 API 使用有点麻烦，要先获取设备的蓝牙适配器，接着注册广播来接受蓝牙设备信息，用完了还需要将广播给注销，相对来说有点麻烦。
不好封装，可以说是原生 Android 最让人痛苦的地方，这是因为原生 Android 的代码不是很独立，与 Activity、广播等相杂糅。市面上的蓝牙库也是少之又少，先看了看 BleLib，感觉还是换汤不换药，用起来一点也不简洁。
但是 FastLib 封装的就很技巧，基本上能把一个操作的粒度控制在一行内，另外，代码也无需与线程、通知之类的打交道，库中已经帮我们把这些复杂的东西都做完了。
FastBle 的 Github 项目地址在这，大家可以看看：FastBle - GitHub
它的文档也相对比较完整，大家可以查看官方文档来使用它：FastBle - Document
✨ FastBle的使用 0x00 申明权限 只要使用到了蓝牙，申明权限是必不可少的，FastBle 需要的权限如下:
&amp;lt;uses-permission android:name=&amp;#34;android.permission.BLUETOOTH&amp;#34; /&amp;gt; &amp;lt;uses-permission android:name=&amp;#34;android.permission.BLUETOOTH_ADMIN&amp;#34; /&amp;gt; &amp;lt;uses-permission android:name=&amp;#34;android.permission.ACCESS_COARSE_LOCATION&amp;#34; /&amp;gt; &amp;lt;uses-permission android:name=&amp;#34;android.permission.ACCESS_FINE_LOCATION&amp;#34; /&amp;gt; 这里要注意一点，如果 Android 版本高于 6.0，用户还需要打开位置信息(不光要位置权限，还需要打开位置信息)才能通过蓝牙进行扫描。
0x01 初始化与全局配置 初始化需要在库中任何函数被调用前执行，由于库使用的是单例模式，只需要初始化一次，在哪里都能使用，建议在 onCreate 里执行初始化代码：
BleManager.getInstance().init(getApplication()); 全局配置可以紧跟初始化之后执行，当然如果不进行配置也没有任何关系，每一个选项都有默认值：
BleManager.getInstance() .enableLog(true) .setReConnectCount(1, 5000) .setSplitWriteNum(20) .setConnectOverTime(10000) .setOperateTimeout(5000); 每一项的详细信息你都能在官方文档中找到说明
0x02 打开蓝牙 使用 FastBle 中的 BleManager 类有很多种方式来打开蓝牙，这里推荐使用下面这种方式，这种方式会使线程被阻塞，如果用户不选择是否打开蓝牙，线程将会暂停执行：</description></item></channel></rss>