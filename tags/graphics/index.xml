<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Graphics on Kindem的博客</title><link>https://www.kindem.xyz/tags/graphics/</link><description>Recent content in Graphics on Kindem的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 20 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://www.kindem.xyz/tags/graphics/index.xml" rel="self" type="application/rss+xml"/><item><title>Explosion 开发笔记 (四)</title><link>https://www.kindem.xyz/post/44/</link><pubDate>Tue, 20 Jul 2021 00:00:00 +0000</pubDate><guid>https://www.kindem.xyz/post/44/</guid><description>前两个月在 Explosion 上下了不少功夫，好几周双休都抽出了一整天来开发引擎、做之后的设计，平日里下班了也是第一时间埋着头就开始写。直到这两周，Explosion 又暂停了下来，主要因为去杭州出差了，项目比较忙，没什么时间写。
今天下班比较早，想起来了该要写笔记了，就提笔记录记录。
近期进展 System / SystemGroup / SystemGraph ECS 框架我们是直接引用的 EnTT，但 EnTT 只提供了 Entity、Component 的概念，没有直接提供 System，它的本意是只负责 ECS 框架中最困难的内存管理部分，所以 System 的概念需要自己封装。
在基础的 System 定义上，我们稍作了简化，并添加了 SystemGroup 和 SystemGraph 的概念，他们的定义如下：
System：一个 Lambda 表达式，即代表一段可执行的逻辑。 SystemGroup：保存了一组 System 和一个 SystemGraph。 SystemGraph：描述了 SystemGroup 内部 System 之间的依赖关系。 另外，他们遵循如下规则：
World#Tick() 会更新所有 SystemGroup，SystemGroup 具有优先级，SystemGroup 之间会按照优先级串行更新。 SystemGroup 内部的所有 System 会按照 SystemGraph 编译成一个 TaskFlow，用于描述一个更新任务。 TaskFlow Execute 的时候有依赖关系的 System 会进行软同步，按照先后顺序执行，没有依赖关系的 System 会并行执行。 System 之间可以拥有共享内存，也使用 Component 实现，我们称之为 SharedComponent，SystemGraph 产生的依赖关系可以保证这块内存的同步访问。 下面是部分定义以及 World#Tick() 的部分代码：</description></item><item><title>Explosion 开发笔记 (三)</title><link>https://www.kindem.xyz/post/40/</link><pubDate>Thu, 27 May 2021 00:00:00 +0000</pubDate><guid>https://www.kindem.xyz/post/40/</guid><description>进展概览 Repo 建设 先说说最近的进展吧，首先是 Repo 方面的建设，README 先写起来占坑了，顺便随手自己画了张 logo 图上丢上去占坑，可以简单看看现在的 README：
README 回头还需要把中文版的 README 和其他的细节慢慢补起来，不过我们现在真没太多人力投入这块，要做的东西太多了，之后把引擎本身完善的差不多了之后再慢慢弄吧。
工程管理 我们在团队内推崇大家使用 Issues 来交流、跟踪进展，使用 Project 来管理整个项目，大概效果是这样：
Issues Project 提交 Issues 会自动关联到 Project，MR 中需要关联对应的 Issues，在 MR 关闭时，Issues 会自动跟随 MR 关闭，并移动到 Project 的 Done 一栏，这样我们就能方便地跟踪需求和进展。
CI CI 方面我们目前使用的是 GitHub Actions，不得不说这玩意可塑性要比其他的 CI/CD 工具强很多，写起来也是比较方便的，目前 CI 就配置了一个 cmake 构建，覆盖平台有：
Ubuntu Windows 具体的代码在这：Actions Code，提交 MR 后自动触发，构建结果可以在 Actions 查询：
Action Result 构建通过是合入的硬性指标。其实我在纠结 MacOS 要不要加，因为实际上从构建来说，MacOS 的编译器和 GCC 还是比较一致的，一般不会出什么大岔子，后面再说吧。
构建系统优化 我抽空对所有的 CMake 进行了一次重构，主要做的事情是把常用的一些基本 CMake 指令做了一次封装，主要涉及：</description></item><item><title>Explosion 开发笔记 (二)</title><link>https://www.kindem.xyz/post/37/</link><pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate><guid>https://www.kindem.xyz/post/37/</guid><description>第一个三角形！ 先说说近期的进展吧，最大头的成果就是趁着五一假期把 VulkanDriver 基本写完了，经典三角形：
Triangle 基本的接口封的差不多了，后面的小问题再慢慢修修补补吧。
然后就是工程建设方面的，差不多这段时间把这些东西搞起来了：
CI (GitHub Action) 三方库 Git SubModule 支持 README / WiKi 单元测试框架本来想加上，但想到目前也只有 Driver，没什么写 UT 的必要性，想想也就算了，等到后面慢慢有需要再加吧，反正集成 UT 框架也就是几行 CMake 的事情。
接下来要做的是 RPI、Runtime、场景管理等，还得把预置的 Components、Systems 给加上，总之好好加油吧。
不省心的 RHI RHI 是写引擎绕不开的巨坑，时常想吐槽这么多 API，你们相互之间打一架好不好，这么多年了也一直搞不出一个统一的 API，各个平台都想围绕自己打造封闭的生态。
写 RHI 最难的事情就是要拿一套统一的接口去封装多个图形 API，于是乎割舍功能和删删改改变成了常态，称 RHI 为脏活累活一点不过分。对各个 API 的了解程度将直接决定 RHI 最终接口的实用程度。
别的很多东西其实可以借鉴老哥们，但是针对 RHI 这层来说，老大哥们的封装其实也不咋地，因为以前的 API 粒度毕竟是较 High Level 的（如 OpenGL、DX9 一类的），很多情况下无法发挥完全能效，再或者看看 CryEngine，索性直接 typedef 实现多态，硬生生把 RHI 和 RPI 糊在一起，只要我没有 RHI，最不存在烦恼，嗯，没毛病。
之前也听同事吐槽过，自己造引擎如果从底层开始写，写到最后发现自己删了好几遍代码，写来写去最后还是一个三角形，上面的啥也没写。
我目前的想法是先按照 Vulkan 的概念简单封装后搭建 Driver 的公共接口，这样上面的 RPI 和游戏逻辑框架也可以先写起来了，日后再慢慢补充 DX12Driver 和 MetalDriver。</description></item><item><title>MacOS 编译 RenderDoc</title><link>https://www.kindem.xyz/post/36/</link><pubDate>Mon, 03 May 2021 00:00:00 +0000</pubDate><guid>https://www.kindem.xyz/post/36/</guid><description>安装依赖 需要安装的依赖如下：
autoconf automake Qt5 其中 Qt5 是 RenderDoc 的界面库，autoconf 和 automake 在构建 c 胶水层生成工具 swig 会使用到。
我们可以直接使用 brew 依次安装所有依赖：
brew install autoconf brew install automake brew install qt5 完成安装后，还需要配置一下 Qt5 的 bin 目录到 PATH 中：
export PATH=&amp;#34;/usr/local/opt/qt@5/bin:$PATH&amp;#34; 编译 RenderDoc 首先下载源码，可以直接去 github 下载最新的 release 版本：GitHub - RenderDoc：
RenderDoc - Downloads 下载完成后解压：
tar -xvf renderdoc-1.13.tar.gz 完成后进入 RenderDoc 源码目录使用 CMake 开始构建：
cd renderdoc-1.13 mkdir build cd build cmake .. cmake --build . -j 16 建议构建时开启 VPN，因为会去墙外下载他们修改过的 swig 源码并当场构建，网络不好可能会构建失败。</description></item><item><title>Explosion 开发笔记 (一)</title><link>https://www.kindem.xyz/post/35/</link><pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate><guid>https://www.kindem.xyz/post/35/</guid><description>Explosion 是我新开发的游戏引擎，GitHub 地址在这里： Explosion，预计是一个大大的工程，我也将持续开发与维护，欢迎志同道合的朋友加入与我一同创造新的游戏秩序。我会在博客中持续更新自己开发过程中的一些心得与思考，欢迎大家关注，Explosion 的故事将由此开始。
为什么要做 Explosion 其实早在上大学那会，我就对计算机图形学和游戏开发有着浓厚的兴趣，大一的时候使用过 Unity 和 Unreal 开发过游戏，在计算机图形学课程设计中，也使用过 OpenGL 2.0，当时大二大三那会接触到了 Web 开发，后来就一直沉迷于 Web 无法自拔了。
机缘巧合下，我的工作却恰好又是跟图形学相关，第一次接触可编程渲染管线（那会是使用 OpenGL）的时候，我仿佛打开了新世界的大门，复杂的游戏场景原来都是由这样的原语构成。
加上自己的兴趣爱好（当然是电子游戏！）使然，组织架构调整的时候我毅然加入了实验室的渲染引擎组，开始参与渲染引擎的开发。
再后来我接触到了 Vulkan、DX12、Metal 等更现代的 GraphicsAPI，同时也逐渐了解了硬件的工作原理，也逐渐理解了游戏底层神秘的引擎到底是怎么运作的，兴趣越来越浓。
俗话说的好，认识一门技术最好的方法就是造轮子，于是我义务反顾地投入了游戏引擎开发大军。
谈谈前辈们 我心目中的游戏引擎一哥当然是 Unreal，老二是 Unity，全封闭的引擎生态这里就不提了。
Unreal 的优点当然是不需要做很多的额外开发，就能获得相当不错的画质效果，相反，缺点则是如果你不是很懂一些渲染的原理，Unreal 对你将会很不友好，很多时候，读它给的文档不如直接读源码。另外如果要加一些自己的扩展特性的话，一旦涉及到渲染管线，大概率要改代码然后再源码编引擎，不过，Unreal 自己的意思也很明确了，老子开源，给你看你不会改，怪谁？
Unity 的话，对开发者的友好程度就要好很多了，文档、资料、教程相当多，C# 写起来也相对比较舒服。Unity 的画质不自己搞的话也就那样了，不过 Unity 也说了，我扩展性这么高，你自己不会写，怪谁？
另外，值得一提的是，针对新的游戏架构 ECS，Unity 在这方面应该算是先驱了，自己已经弄了一套 ECS 的 Preview 接口了，有空可以详细聊聊 Unity 的 ECS。
Unreal 和 Unity 的源码我都读过一部分，Unreal 和 Unity 只能说这种体量的东西是工程界的奇迹，只要架构没有腐坏到无可救药的程度，哪怕局部屎再多也能糊住，多数情况下，它们的代码看起来就是微观来看简直屎的不行，但从宏观架构来看还能过得去。
再下来我了解到的一些引擎有 CryEngine、Cocos、Godot、KlayGE 等。
CryEngine 的代码简直可以用灾难来形容，在其上搭建的 Amazon Lumberyard 也是一个灾难，相信我，只要你看一眼它的 CD3D9Renderer 你就知道我在说什么了。CryEngine 的文档也很差劲，不过好像它的忠实拥趸还挺多，但据我所知，买过它来做游戏的育碧和 EA 都跑路了，CryEngine，把你弄哭的引擎。</description></item><item><title>UnrealEngine4 源码剖析 (二) 垃圾回收</title><link>https://www.kindem.xyz/post/34/</link><pubDate>Tue, 16 Feb 2021 00:00:00 +0000</pubDate><guid>https://www.kindem.xyz/post/34/</guid><description>1. 垃圾回收 垃圾回收（ GC ）可以说是现代编程语言的标配，GC 简单来说就是语言运行时自动判别申请的内存是否还在被使用，判断内存无用后则自动回收内存。内存管理从来就不是什么容易事，需要手动管理内存实际上也是 C/C++ 入门门槛高的一大原因，稍有不慎就会造成内存泄露。
UnrealEngine4 在自己的 Runtime 中实现了 GC 功能，所有使用 NewObject() 或 LoadObject() 方法创建的对象都会受 GC 系统的管制，当对象无用后将会自动释放。
2. UE4 GC 源码阅读 首先我们要知道，在 UE4 中，是不能通过 C++ 内置的操作符 new 来创建对象的，使用 new 创建的对象将不受 UE4 Runtime 的控制，正确的做法是使用 NewObject() 或者 LoadObject() 方法创建或加载对象。
首先我们需要知道，当使用 NewObject() 创建对象后，真正的内存将会被保存至一个全局数组中，另外还需要在一个全局 Hash 表中保存一些其他信息，这部分代码在 /Engine/Source/Runtime/CoreUObject/Private/UObject/UObjectHash.cpp，我们需要关注两个关键信息：
FUObjectArray GUObjectArray; class FUObjectHashTables { // ... static FUObjectHashTables&amp;amp; Get() { static FUObjectHashTables Singleton; return Singleton; } } 其中 GUObjectArray 就是全局对象数组，而 FUObjectHashTables 是一个单例，类内部维护了几张 Hash 表，存储了对象之间的关系。我们先看 GUObjectArray，它的类型是 FUObjectArray：</description></item><item><title>UnrealEngine4 源码剖析 (一) UObject 概览及反射系统</title><link>https://www.kindem.xyz/post/33/</link><pubDate>Wed, 10 Feb 2021 00:00:00 +0000</pubDate><guid>https://www.kindem.xyz/post/33/</guid><description>1 自省、反射 我们先来看一下 Java 中的反射机制定义：
Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性。
定义的前半句即自省，而后半句即反射。使用 UE4 的朋友应该大多数都是 C++ 开发者，但是如果大家使用过一些 C++ 之外的现代语言，就会明白自省和反射的重要性。
自省与反射的用途非常广泛，比如很多语言（如 Python）的命令行脚本解释器、对象的自动序列化（通过自省遍历属性并依次序列化）、QT 的信号槽等，都是基于自省与反射实现的。
仔细想一想，其实要实现语言层面的自省与反射，是很简单的，只需要在编译字节码 / 二进制的时候额外写入类、属性、方法的类型信息即可。但是 C++ 由于年龄实在太大，在设计之初并没有考虑如此基础的功能，以至于到现在为止，C++ 也没在标准中提供自省与反射的语言支持。
但是人们的智慧是无穷无尽的，很多使用 C++ 构建的软件都会选择自己实现一套反射系统。目前已知的套路有两种：
手动注册类型信息 预编译器生成类型信息 手动注册类型信息就显得很简单粗暴了，这里有一个有名的库，叫做 rttr，上一段代码，你就秒懂他的原理了：
#include &amp;lt;rttr/registration&amp;gt; using namespace rttr; struct MyStruct { MyStruct() {}; void func(double) {}; int data; }; RTTR_REGISTRATION { registration::class_&amp;lt;MyStruct&amp;gt;(&amp;#34;MyStruct&amp;#34;) .constructor&amp;lt;&amp;gt;() .property(&amp;#34;data&amp;#34;, &amp;amp;MyStruct::data) .method(&amp;#34;func&amp;#34;, &amp;amp;MyStruct::func); } 这里使用 rttr 库注册了一个名为 MyStruct 的结构体，代码很简单，就是在一个静态块中手动注册了 MyStruct 的属性与方法。在完成注册之后，就可以开始经典的反射操作了，如遍历属性：
type t = type::get&amp;lt;MyStruct&amp;gt;(); for (auto&amp;amp; prop : t.</description></item><item><title>MacOS 搭建 OpenGL 开发环境</title><link>https://www.kindem.xyz/post/26/</link><pubDate>Tue, 21 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.kindem.xyz/post/26/</guid><description>准备工作 首先确认自己的 MacOS 上已经安装了 gcc：
gcc --version 可以看到版本号：
kindem@JohndeMacBook-Pro ~ % gcc --version Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/Applic ations/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++ /4.2.1 Apple clang version 11.0.3 (clang-1103.0.32.59) Target: x86_64-apple-darwin19.3.0 Thread model: posix InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin kindem@JohndeMacBook-Pro ~ % 如果没有安装的话会上面的指令会自动触发 XCode 下载并安装，根据提示安装完成之后再使用上面的指令检查一遍即可。
接着安装 CLion，个人是极其推荐使用 JetBrain 家的 IDE 进行开发的，可以在如下网站下载：CLion - JetBrain，下载完成后自行完成安装与激活即可。
安装完 CLion 之后，可以在 Settings 中检查 Toolchain 是否正确识别，如下：
Toolchain 通常来说只需要安装好 gcc 即可，因为 cmake 会在 CLion 中自带，而 make 会在 MacOS 系统中提供。
下载依赖库 通常来说，搭建 OpenGL 的开发环境需要两剑客：
GLFW: 提供跨平台的 OpenGL 上下文初始化与窗口创建等功能 GLAD: 提供跨平台的 OpenGL 函数指针加载等功能 我们按照顺序分别下载这些库，首先是 GLFW，地址在这：Download - GLFW，GLFW 在不同的平台上都有预编译好的包，我们根据我们的系统下载 MacOS 版本的预编译包：</description></item></channel></rss>