<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CPP on Kindem的博客</title><link>https://flyandnotdown.github.io/tags/cpp/</link><description>Recent content in CPP on Kindem的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 26 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://flyandnotdown.github.io/tags/cpp/index.xml" rel="self" type="application/rss+xml"/><item><title>MSVC std::unique_ptr 源码解析</title><link>https://flyandnotdown.github.io/post/48/</link><pubDate>Sun, 26 Sep 2021 00:00:00 +0000</pubDate><guid>https://flyandnotdown.github.io/post/48/</guid><description>介绍 std::unique_ptr 是 c++ 11 添加的智能指针之一，是裸指针的封装，我们可以直接使用裸指针来构造 std::unique_ptr：
struct TestStruct { int a; int b; }; class TestClass { public: TestClass() = default; TestClass(int a, int b) : a(a), b(b) {} private: int a; int b; }; std::unique_ptr&amp;lt;int&amp;gt; p0 = std::unique_ptr&amp;lt;int&amp;gt;(new int { 1 }); std::unique_ptr&amp;lt;TestStruct&amp;gt; p1 = std::unique_ptr&amp;lt;TestStruct&amp;gt;(new TestStruct { 1, 2 }); std::unique_ptr&amp;lt;TestClass&amp;gt; p2 = std::unique_ptr&amp;lt;TestClass&amp;gt;(new TestClass(1, 2)); 在 c++ 14 及以上，可以使用 std::make_unique 来更方便地构造 std::unique_ptr，参数列表需匹配创建对象的构造函数：
std::unique_ptr&amp;lt;int&amp;gt; p0 = std::make_unique&amp;lt;int&amp;gt;(1); std::unique_ptr&amp;lt;TestStruct&amp;gt; p1 = std::make_unique&amp;lt;TestStruct&amp;gt;(TestStruct { 1, 2 }); std::unique_ptr&amp;lt;TestClass&amp;gt; p2 = std::make_unique&amp;lt;TestClass&amp;gt;(1, 2); 除了保存普通对象，std::unique_ptr 还能保存数组，这时 std::make_unique 的参数表示数组的长度：</description></item><item><title>MSVC std::any 源码解析</title><link>https://flyandnotdown.github.io/post/46/</link><pubDate>Sat, 28 Aug 2021 00:00:00 +0000</pubDate><guid>https://flyandnotdown.github.io/post/46/</guid><description>std::any 介绍 std::any 是 c++17 标准新提供的类，作用是存储任意类型的一段内存，并可以重复赋值，在赋值后可以使用 std::any_cast 将 std::any 所存储的值转换成特定类型，如果 std::any 中存储的值的类型与目标类型不匹配，则会抛出 std::bad_any_cast 异常。
下面是一些简单的 Sample Code（MSVC 16 2019 64Bit 运行）：
std::any value = 1.0; // 1 std::cout &amp;lt;&amp;lt; any_cast&amp;lt;double&amp;gt;(value) &amp;lt;&amp;lt; std::endl; // 抛出 std::bad_any_cast 异常 std::cout &amp;lt;&amp;lt; any_cast&amp;lt;float&amp;gt;(value) &amp;lt;&amp;lt; std::endl; // 抛出 std::bad_any_cast 异常 std::cout &amp;lt;&amp;lt; any_cast&amp;lt;int&amp;gt;(value) &amp;lt;&amp;lt; std::endl; 指针示例：
std::any value1 = nullptr; // nullptr std::cout &amp;lt;&amp;lt; any_cast&amp;lt;nullptr_t&amp;gt;(value1) &amp;lt;&amp;lt; std::endl; // 抛出 std::bad_any_cast 异常 std::cout &amp;lt;&amp;lt; any_cast&amp;lt;int*&amp;gt;(value1) &amp;lt;&amp;lt; std::endl; std::any value2 = (int*) (nullptr); // 抛出 std::bad_any_cast 异常 std::cout &amp;lt;&amp;lt; any_cast&amp;lt;nullptr_t&amp;gt;(value2) &amp;lt;&amp;lt; std::endl; // 0000000000000000 std::cout &amp;lt;&amp;lt; any_cast&amp;lt;int*&amp;gt;(value2) &amp;lt;&amp;lt; std::endl; 空 std::any 示例：</description></item><item><title>std::tuple 学习笔记</title><link>https://flyandnotdown.github.io/post/42/</link><pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate><guid>https://flyandnotdown.github.io/post/42/</guid><description>std::tuple 是泛化的 std::pair，用于存储一组任意类型的数据，可以通过 std::get 来访问其元素：
int main(int argc, char* argv[]) { std::tuple&amp;lt;int, double, std::string&amp;gt; tuple = std::make_tuple(1, 2.0, &amp;#34;hello&amp;#34;); std::cout &amp;lt;&amp;lt; std::get&amp;lt;0&amp;gt;(tuple) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; std::get&amp;lt;1&amp;gt;(tuple) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; std::get&amp;lt;2&amp;gt;(tuple) &amp;lt;&amp;lt; std::endl; } 也可以使用类型来查找元素：
int main(int argc, char* argv[]) { std::tuple&amp;lt;int, double, std::string&amp;gt; tuple = std::make_tuple(1, 2.0, &amp;#34;hello&amp;#34;); std::cout &amp;lt;&amp;lt; std::get&amp;lt;int&amp;gt;(tuple) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; std::get&amp;lt;double&amp;gt;(tuple) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; std::get&amp;lt;std::string&amp;gt;(tuple) &amp;lt;&amp;lt; std::endl; } 如果 std::tuple 中具有两个以上的相同类型的元素，则不能使用该类型进行查找：
int main(int argc, char* argv[]) { std::tuple&amp;lt;int, int, std::string&amp;gt; tuple = std::make_tuple(1, 2, &amp;#34;hello&amp;#34;); // 编译期错误 std::cout &amp;lt;&amp;lt; std::get&amp;lt;int&amp;gt;(tuple) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; std::get&amp;lt;int&amp;gt;(tuple) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; std::get&amp;lt;std::string&amp;gt;(tuple) &amp;lt;&amp;lt; std::endl; } 可以使用 std::tie 来对 std::tuple 进行解包：</description></item><item><title>醒醒吧，静态多态根本没有这么香</title><link>https://flyandnotdown.github.io/post/39/</link><pubDate>Sun, 16 May 2021 00:00:00 +0000</pubDate><guid>https://flyandnotdown.github.io/post/39/</guid><description>CRTP CRTP 全称 Curiously Recurring Template Pattern，即奇异递归模板模式，是一种经典的 C++ 设计模式，听起来很反人类，我们先来看一段代码：
#include &amp;lt;iostream&amp;gt; template &amp;lt;class T&amp;gt; class Base { public: void Foo() { static_cast&amp;lt;T*&amp;gt;(this)-&amp;gt;FooImpl(); } }; class Child1 : public Base&amp;lt;Child1&amp;gt; { public: void FooImpl() { std::cout &amp;lt;&amp;lt; &amp;#34;hello1&amp;#34; &amp;lt;&amp;lt; std::endl; } }; class Child2 : public Base&amp;lt;Child2&amp;gt; { public: void FooImpl() { std::cout &amp;lt;&amp;lt; &amp;#34;hello2&amp;#34; &amp;lt;&amp;lt; std::endl; } }; template &amp;lt;class T&amp;gt; void Print(Base&amp;lt;T&amp;gt;&amp;amp; base) { base.Foo(); } int main(int argc, char* argv[]) { Child1 child1; Child2 child2; Print(child1); Print(child2); } 这是一个 CRTP 的典型使用场景 —— 静态多态，其实很容易理解，如果需要在编译期让父类的某个方法调用子类的方法，那必然需要让父类能够感知到子类的类型信息，因为你需要将 this 指针转换成子类指针才能调用对应方法。</description></item></channel></rss>