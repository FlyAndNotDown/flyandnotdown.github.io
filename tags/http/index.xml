<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Http on Kindem的博客</title><link>https://flyandnotdown.github.io/tags/http/</link><description>Recent content in Http on Kindem的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 30 Aug 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://flyandnotdown.github.io/tags/http/index.xml" rel="self" type="application/rss+xml"/><item><title>Ajax 跨域</title><link>https://flyandnotdown.github.io/post/14/</link><pubDate>Thu, 30 Aug 2018 00:00:00 +0000</pubDate><guid>https://flyandnotdown.github.io/post/14/</guid><description>🤔 Ajax跨域简介 所谓 Ajax 跨域指的是 Ajax 请求从其他的域获取数据或者传输数据
所谓域同源，指的是两个服务器资源的根 url 的域名、端口、协议三者完全相同，只要三者中任何一个不同，则说明产生了跨域
给一个例子，对于第一个服务器资源，其他一些 url 的同源情况如下:
http://www.test.com/index.html http://www.test.com/index.js 同源 http://www.test.com/login/login.js 同源 https://www.test.com/index.html 跨域(协议) http://www.a.com/index.html 跨域(域名) http://a.com/index.html 跨域(不同子域) http://www.test.com:8080/index.html 跨域(端口) 🥤 常用跨域方法 CORS CORS 是一个 W3C 标准，其全称为 Cross-Origin Resource Sharing，即跨域资源共享。它允许浏览器向跨域服务器发送 XMLHttpRequest 请求，从而克服了 Ajax 只能同源使用的限制
CORS 需要浏览器和服务器同时支持，目前主流浏览器都支持这个标准( IE&amp;gt;=10 )，所以 CORS 的关键主要在于服务器，要支持这个功能，往往开发者需要在服务器端进行额外设置
另外，CORS 标准对用户来说是透明的，用户感知不到 CORS 的存在，一切都是浏览器自动完成。当浏览器检测到跨域的 Ajax 请求时，就会自动做出一些处理，使得请求能够跨域
跨域的 Ajax 请求分为两种：
简单请求: 请求方法为 HEAD、POST、GET 之一 HTTP 头字段只有 Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type 中的一种或多种 HTTP 头字段中的 Content-Type 字段的取值为 application/x-www-form-urlencoded、multipart/form-data、text/plain 之一 非简单请求: 所有不满足上述规则的请求 CORS 对于两种不同的请求的处理是不同的</description></item><item><title>使用原生 JavaScript 封装 Ajax 操作</title><link>https://flyandnotdown.github.io/post/5/</link><pubDate>Tue, 24 Apr 2018 00:00:00 +0000</pubDate><guid>https://flyandnotdown.github.io/post/5/</guid><description>📦 封装举例 export class Ajax { static get(url, data, hook) { let xmlHttpRequest = new XMLHttpRequest(); url += &amp;#39;?&amp;#39;; let count = -1; for (let key in data) { count++; if (data.hasOwnProperty(key)) { url += count === 0 ? key + &amp;#39;=&amp;#39; + data[key] : &amp;#39;&amp;amp;&amp;#39; + key + &amp;#39;=&amp;#39; + data[key]; } } xmlHttpRequest.open(&amp;#39;GET&amp;#39;, url, true); xmlHttpRequest.onreadystatechange = () =&amp;gt; { if (xmlHttpRequest.readyState === 4 &amp;amp;&amp;amp; xmlHttpRequest.status === 200 || xmlHttpRequest.</description></item></channel></rss>