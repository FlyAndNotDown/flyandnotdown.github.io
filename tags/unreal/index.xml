<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Unreal on Kindem的博客</title><link>https://flyandnotdown.github.io/tags/unreal/</link><description>Recent content in Unreal on Kindem的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 16 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://flyandnotdown.github.io/tags/unreal/index.xml" rel="self" type="application/rss+xml"/><item><title>UnrealEngine4 源码剖析 (二) 垃圾回收</title><link>https://flyandnotdown.github.io/post/34/</link><pubDate>Tue, 16 Feb 2021 00:00:00 +0000</pubDate><guid>https://flyandnotdown.github.io/post/34/</guid><description>1. 垃圾回收 垃圾回收（ GC ）可以说是现代编程语言的标配，GC 简单来说就是语言运行时自动判别申请的内存是否还在被使用，判断内存无用后则自动回收内存。内存管理从来就不是什么容易事，需要手动管理内存实际上也是 C/C++ 入门门槛高的一大原因，稍有不慎就会造成内存泄露。
UnrealEngine4 在自己的 Runtime 中实现了 GC 功能，所有使用 NewObject() 或 LoadObject() 方法创建的对象都会受 GC 系统的管制，当对象无用后将会自动释放。
2. UE4 GC 源码阅读 首先我们要知道，在 UE4 中，是不能通过 C++ 内置的操作符 new 来创建对象的，使用 new 创建的对象将不受 UE4 Runtime 的控制，正确的做法是使用 NewObject() 或者 LoadObject() 方法创建或加载对象。
首先我们需要知道，当使用 NewObject() 创建对象后，真正的内存将会被保存至一个全局数组中，另外还需要在一个全局 Hash 表中保存一些其他信息，这部分代码在 /Engine/Source/Runtime/CoreUObject/Private/UObject/UObjectHash.cpp，我们需要关注两个关键信息：
FUObjectArray GUObjectArray; class FUObjectHashTables { // ... static FUObjectHashTables&amp;amp; Get() { static FUObjectHashTables Singleton; return Singleton; } } 其中 GUObjectArray 就是全局对象数组，而 FUObjectHashTables 是一个单例，类内部维护了几张 Hash 表，存储了对象之间的关系。我们先看 GUObjectArray，它的类型是 FUObjectArray：</description></item><item><title>UnrealEngine4 源码剖析 (一) UObject 概览及反射系统</title><link>https://flyandnotdown.github.io/post/33/</link><pubDate>Wed, 10 Feb 2021 00:00:00 +0000</pubDate><guid>https://flyandnotdown.github.io/post/33/</guid><description>1 自省、反射 我们先来看一下 Java 中的反射机制定义：
Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性。
定义的前半句即自省，而后半句即反射。使用 UE4 的朋友应该大多数都是 C++ 开发者，但是如果大家使用过一些 C++ 之外的现代语言，就会明白自省和反射的重要性。
自省与反射的用途非常广泛，比如很多语言（如 Python）的命令行脚本解释器、对象的自动序列化（通过自省遍历属性并依次序列化）、QT 的信号槽等，都是基于自省与反射实现的。
仔细想一想，其实要实现语言层面的自省与反射，是很简单的，只需要在编译字节码 / 二进制的时候额外写入类、属性、方法的类型信息即可。但是 C++ 由于年龄实在太大，在设计之初并没有考虑如此基础的功能，以至于到现在为止，C++ 也没在标准中提供自省与反射的语言支持。
但是人们的智慧是无穷无尽的，很多使用 C++ 构建的软件都会选择自己实现一套反射系统。目前已知的套路有两种：
手动注册类型信息 预编译器生成类型信息 手动注册类型信息就显得很简单粗暴了，这里有一个有名的库，叫做 rttr，上一段代码，你就秒懂他的原理了：
#include &amp;lt;rttr/registration&amp;gt; using namespace rttr; struct MyStruct { MyStruct() {}; void func(double) {}; int data; }; RTTR_REGISTRATION { registration::class_&amp;lt;MyStruct&amp;gt;(&amp;#34;MyStruct&amp;#34;) .constructor&amp;lt;&amp;gt;() .property(&amp;#34;data&amp;#34;, &amp;amp;MyStruct::data) .method(&amp;#34;func&amp;#34;, &amp;amp;MyStruct::func); } 这里使用 rttr 库注册了一个名为 MyStruct 的结构体，代码很简单，就是在一个静态块中手动注册了 MyStruct 的属性与方法。在完成注册之后，就可以开始经典的反射操作了，如遍历属性：
type t = type::get&amp;lt;MyStruct&amp;gt;(); for (auto&amp;amp; prop : t.</description></item></channel></rss>