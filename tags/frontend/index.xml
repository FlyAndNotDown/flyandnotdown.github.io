<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Frontend on Kindem的博客</title><link>https://flyandnotdown.github.io/tags/frontend/</link><description>Recent content in Frontend on Kindem的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 11 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://flyandnotdown.github.io/tags/frontend/index.xml" rel="self" type="application/rss+xml"/><item><title>Web 杂记 | 为什么我称这个 Web 时代是静态页面的文艺复兴？</title><link>https://flyandnotdown.github.io/post/38/</link><pubDate>Tue, 11 May 2021 00:00:00 +0000</pubDate><guid>https://flyandnotdown.github.io/post/38/</guid><description>SPA 它真的香吗？ 我喜欢用三个里程碑来界定目前 Web 发展的历史：
HTML + CSS + JavaScript 模式的诞生 -&amp;gt; 静态页面时代 Server-Side-Render (SSR) 的诞生 -&amp;gt; 动态页面时代 React / Vue / Angular 的普及 -&amp;gt; SPA 时代 在远古时期，网页的组成其实非常简单，简单来说以前的服务器其实就是简单的文件服务器，上面只存放 HTML、CSS、JavaScript 文件，而用户通过浏览器去访问页面，实际上就是把文件下载下来跑起来而已。
SSR 的诞生，催化了 Web 的极速发展，实际上跟静态页面的变化只是之前固定的 HTML 页面变成了由服务器根据模板引擎动态拼接 HTML 字符串返回而已，但仅仅是这么一点变化，就让原本静态的网页，产生了丰富多彩的组合，各种论坛像雨后春笋一样狂野生长，这段时间也诞生了一大批轮子，WordPress、JavaWeb、.NetWeb，可以说这些轮子是那个年代 Web 人的烂漫。
近几年 React / Vue 一类的 SPA 框架出来之后，可以说一时间前端界为之癫狂，再加上 Node.js / NPM 生态的繁荣，一时间乱花渐欲迷人眼，所有人都被 SPA 惊艳到了。
所谓 SPA，全称 Single-Page-Application，简单来说就是把部分以前 Server-Side 做的事情放到了 Browser-Side，服务器只负责把静态资源 (HTML, CSS, JavaScript, Images) 打包好返回给前端，然后由前端自己来进行 HTML Document 的渲染。
从架构上来看，SPA 简直酷炫无比，因为它的设计原则是把整个网站当成一个应用来看待，加载站点的过程实际上就像下载一个资源包，下载好资源包之后就把控制权完全交由应用，让应用自己负责，服务器只负责提供资源和处理一些 Ajax 数据请求。</description></item><item><title>在 Electron + React 中使用 Node.js 模块</title><link>https://flyandnotdown.github.io/post/18/</link><pubDate>Sat, 13 Jul 2019 00:00:00 +0000</pubDate><guid>https://flyandnotdown.github.io/post/18/</guid><description>🤔 问题 如果在 Electron 中使用 React，在 React 组件中调用 Node.js 模块会抛出错误，告知你模块或者模块中的方法不存在，这是因为默认情况下 Electron 模拟的是纯浏览器环境，而浏览器中自然无法直接使用 Node.js 模块，如果需要使用 Node.js 模块，需要进行额外的配置。
🎉 解决方法 在创建 Electron 中的 BrowserWindow 对象的时候，进行额外配置，启用 webPreferences 中的 nodeIntegration 和 nodeIntegrationInWorker，使之支持 Node.js 模块：
let window = new BrowserWindow({ width: 800, height: 600, webPreferences: { nodeIntegration: true, nodeIntegrationInWorker: true } }); 完成这一步后，如果使用了 babel 进行编译，则可以直接使用：
import path from &amp;#39;path&amp;#39;; 这样的形式引用 Node.js 模块，如果没有使用 babel，则需要使用：
const path = window.require(&amp;#39;path&amp;#39;); 来引用 Node.js 模块。</description></item><item><title>在 react-app-rewired 中使用 uglify.js</title><link>https://flyandnotdown.github.io/post/17/</link><pubDate>Fri, 22 Mar 2019 00:00:00 +0000</pubDate><guid>https://flyandnotdown.github.io/post/17/</guid><description>🤔 起因 今天遇到一个玄学的 bug，主要是因为引入了 pinyin 包，这个包其中的一行代码会导致 Webpack 默认使用的 Minifier 失效，从而导致编译失败。
经过一份排查和寻求帮助，我发现可以通过在 Webpack 中引入 uglifyjs 这一插件来解决。
但是我使用的是 create-react-app 创建的 React 项目，这样一来 Webpack 的配置将会被隐藏，需要使用 react-app-rewired 来暴露位于 node_modules 目录下的 Webpack 配置，但是网上并没有找到关于在 react-app-rewired 中添加 uglifyjs 插件的方法。
🎉 解决办法 在 npm 上搜寻了一番，找到了一个宝贝 &amp;ndash; react-app-rewire-uglifyjs，通过这个包可以直接在 react-app-rewired 中使用 uglifyjs，使用方法如下：
在 react-app-rewired 的配置文件 /config-overrides.js 这样写：
const rewireUglifyjs = require(&amp;#39;react-app-rewire-uglifyjs&amp;#39;); module.exports = function override(config, env) { // use UglifyJS config = rewireUglifyjs(config); return config; }; 文档可以参考这里：npm - react-app-rewire-uglifyjs</description></item></channel></rss>