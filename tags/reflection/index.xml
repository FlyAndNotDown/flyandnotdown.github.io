<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Reflection on Kindem的博客</title><link>https://flyandnotdown.github.io/tags/reflection/</link><description>Recent content in Reflection on Kindem的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 25 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://flyandnotdown.github.io/tags/reflection/index.xml" rel="self" type="application/rss+xml"/><item><title>如何以酷炫的姿势造一个 C++ 动态反射轮子</title><link>https://flyandnotdown.github.io/post/58/</link><pubDate>Sat, 25 Nov 2023 00:00:00 +0000</pubDate><guid>https://flyandnotdown.github.io/post/58/</guid><description>背景 写游戏引擎当然绕不开反射，反射在编辑器开发、序列化这块有着举足轻重的作用。
简单扫了一遍市面上的动态反射库，rttr 感觉已经不更新了，实际上用 CMake 集成到项目里感觉也不太好用，meta 其实还不错，思路很好，用模板做类型注册，但是比较整蛊的是查类型信息的使用用的不是 std::string，而是一个 hash 值，其实就是编译期字符串 hash，不够灵活，另外还缺一套自动注册的流程。UE 的反射库也比较完善，主要基于地址注册，而且有自动注册流程，但是缺点就是太依赖 UObject 系统了，而且年代久远所以相当笨重，独立项目不可能去引用的。
于是我打算自己造一套轮子，整体框架参考 meta，类型注册使用模板，引入 libclang 来做头文件的自动分析与类型自动注册，另外也支持已注册类型的对象自动序列化。
我给这套反射框架取名叫 Mirror，镜子反射很6，简单粗暴没毛病，你可以在 Explosion/Mirror 和 Explosion/MirrorTool 找到所有的相关代码和测试用例，让我们开始吧。
TypeInfo 首先我们需要为我们的类型构筑一个基本信息，直接给一个结构体，描述某一个类型的基本信息，这个信息后面会在很多地方用到，比如判断类型是否相等啦，Any Cast 的校验啦、派生关系的校验啦之类的。
using TypeId = size_t; struct TypeInfo { std::string name; TypeId id; const bool isConst; const bool isLValueReference; const bool isRValueReference; const bool isPointer; const bool isClass; TypeId removePointerType; }; 其实就是类型名、id、然后一些基本的 type traits，和一个 removePointerType，这些信息基本已经足够了，如果还需要别的可以在此基础上添加定制。
接下来我们需要一个模板函数，支持对一个类型求 TypeInfo：
template &amp;lt;typename T&amp;gt; TypeInfo* GetTypeInfo() { static TypeInfo typeInfo = { typeid(T).</description></item></channel></rss>